{"total":36,"pageSize":10,"pageCount":4,"data":[{"title":"HTTP Structure","slug":"HTTP-Structure","date":"2021-04-27T00:05:54.000Z","updated":"2021-04-27T00:18:52.856Z","comments":true,"pin":null,"path":"api/articles/HTTP-Structure.json","excerpt":"","keywords":null,"cover":"https://user-images.githubusercontent.com/62123161/116166199-72be1880-a738-11eb-9d98-9c81fbc1cbba.png","content":"<h2 id=\"통신-Method\"><a href=\"#통신-Method\" class=\"headerlink\" title=\"통신 Method\"></a>통신 Method</h2><ul>\n<li><p>GET: 지정된 리소스(URI)를 요청</p>\n</li>\n<li><p>POST: 서버가 클라이언트의 폼 입력 필드 데이터의 수락을 요청. 클라이언트는 서버로 HTTP Body에 Data를 전송</p>\n</li>\n<li><p>HEAD: 문서의 헤더 정보만 요청하며, 응답데이터(body)를 받지 않는다.</p>\n</li>\n<li><p>PUT: 클라이언트가 전송한 데이터를 지정한 uri로 대체한다. ftp의 PUT과 동일하며, 클라이언트는 서버로 HTTP Body에 Data를 전송한다.</p>\n</li>\n<li><p>DELETE: 클라이언트가 지정한 URI를 서버에서 삭제한다.</p>\n</li>\n<li><p>TRACE: 클라이언트가 요청한 자원에 도달하기 까지의 경로를 기록하는 루프백(loop back) 검사용. 클라이언트가 요청 자원에 도달하기 까지 거쳐가는 프록시나 게이트웨이의 중간 경로부터 최종 수진 서버까지의 경로를 알아낼때 사용</p>\n</li>\n</ul>\n<p>ps. Node.js에서 app.all() 사용하는 이유 : app.use는 주로 해당 app이나 router 로 요청할 경우, 반드시 선행되어야하는 함수나 미들웨어를 추가하기 위해 사용한다. 헤더를 따로 설정하여 주기 좋고 모든 Method를 포괄할 수 있는 장점은 있으나, express의 CORS 미들웨어를 적용하는 방식이 편하므로 method를 직접 정해주는 게 나을 것으로 보인다.</p>\n<h2 id=\"Header-분석-및-예시\"><a href=\"#Header-분석-및-예시\" class=\"headerlink\" title=\"Header 분석 및 예시\"></a>Header 분석 및 예시</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET http://goddaehee.tistory.com/168 HTTP/1.1</span><br><span class=\"line\"> </span><br><span class=\"line\">//요청을 한 서버의 Host</span><br><span class=\"line\">Host: goddaehee.tistory.com</span><br><span class=\"line\"> </span><br><span class=\"line\">//클라이언트와 서버의 연결 방식 설정 HTTP/1.1은 kepp-alive 로 연결 유지하는게 디폴트.</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\"> </span><br><span class=\"line\">//클라이언트 소프트웨어(브라우저, os 등)의 이름과 버전 등</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36</span><br><span class=\"line\"> </span><br><span class=\"line\">//클라이언트가 허용할 수 있는 파일 형식(MIME TYPE)</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class=\"line\"> </span><br><span class=\"line\">//특정 페이지에서 링크를 클릭하여 요청을 하였을 경우에 나타나는 필드로써 링크를 제공한 페이지를 나타냄</span><br><span class=\"line\">Referer: http://goddaehee.tistory.com/</span><br><span class=\"line\"> </span><br><span class=\"line\">//클라이언트가 인식할 수 있는 인코딩(압축_방법으로 위의 내용에서는 서버에서 gzip, deflate로 압축한 리소스를 클라이언트가 해석할 수 있다는 말이됨</span><br><span class=\"line\">//만일 서버에서 압축을 했다면 응답헤더에 Content-Encoding 헤더에 해당 압축 방법이 명시됨.</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\"> </span><br><span class=\"line\">//클라이언트가 인식할 수 있는 언어로 우선 순위 지정이 가능</span><br><span class=\"line\">Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span><br><span class=\"line\"> </span><br><span class=\"line\">//웹서버가 클라이언트에 쿠키를 저장해 놓았다면 해당 쿠키의 정보를 이름-값 쌍으로 웹서버에 전송</span><br><span class=\"line\">Cookie: menuEnabled=1;</span><br><span class=\"line\"> </span><br><span class=\"line\">//페이지가 수정되었으면 최신 버전 페이지 요청을 위한 필드, 만일 요청한 파일이 이 필드에 지정된 시간 이후로 변경되지 않았다면, 서버로부터 데이터를 전송받지 않음</span><br><span class=\"line\">If-Modified-Since: Fri, 21 Jul 2006 05:31:13 GMT</span><br><span class=\"line\"> </span><br><span class=\"line\">//서버에 ETag가 달라졌는지 검사를 요청. ETag가 다를 경우에만 컨텐츠를 새로 받음. 만약, ETag가 같다면 서버는 304 Not Modified를 응답해서 캐시를 그대로 사용</span><br><span class=\"line\">If-None-Match: <span class=\"string\">\"734237e186acc61:a1b\"</span></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"이외-HTTP-Header-항목들\"><a href=\"#이외-HTTP-Header-항목들\" class=\"headerlink\" title=\"이외 HTTP Header  항목들\"></a>이외 HTTP Header  항목들</h2><ul>\n<li>Authorization<ul>\n<li>인증 토큰(JWT/Bearer 토큰)을 서버로 보낼 때 사용하는 헤더</li>\n<li>“토큰의 종류(Basic, Bearer 등) + 실제 토큰 문자”를 전송</li>\n</ul>\n</li>\n<li>Origin<ul>\n<li>서버로 POST 요청을 보낼 때, 요청이 어느 주소에서 시작되었는지 나타낸다.</li>\n<li>여기서 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러가 발생한다.</li>\n<li>응답 헤더의 Access-Control-Allow-Origin와 관련</li>\n</ul>\n</li>\n<li>Cache-Control<ul>\n<li>Ex) Cache-Control: no-store<ul>\n<li>아무것도 캐싱하지 않는다.</li>\n</ul>\n</li>\n<li>Ex) Cache-Control: no-cache<ul>\n<li>모든 캐시를 쓰기 전에 서버에 해당 캐시를 사용해도 되는지 확인한다.</li>\n</ul>\n</li>\n<li>Ex) Cache-Control: must-revalidate<ul>\n<li>만료된 캐시만 서버에 확인을 받도록 한다.</li>\n</ul>\n</li>\n<li>Ex) Cache-Control: public<ul>\n<li>공유 캐시(또는 중개 서버)에 저장해도 된다는 것을 의미한다.</li>\n</ul>\n</li>\n<li>Ex) Cache-Control: private<ul>\n<li>브라우저같은 특정 사용자 환경에만 저장한다.</li>\n</ul>\n</li>\n<li>Ex) Cache-Control: max-age<ul>\n<li>캐시 유효시간을 명시한다.</li>\n</ul>\n</li>\n<li>주로 응답 헤더로 사용하지만, “클라이언트 - 중개 서버 - 서버”의 구조에서 중개 서버의 캐시를 가져오지 않도록 하려면 클라이언트에서 요청 헤더에 이 헤더를 추가한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"캐시-쿠키-세션-JWT의-차이\"><a href=\"#캐시-쿠키-세션-JWT의-차이\" class=\"headerlink\" title=\"캐시, 쿠키, 세션, JWT의 차이\"></a>캐시, 쿠키, 세션, JWT의 차이</h2><h3 id=\"캐시-Cache\"><a href=\"#캐시-Cache\" class=\"headerlink\" title=\"캐시 (Cache)\"></a>캐시 (Cache)</h3><ul>\n<li>개념<ul>\n<li>CPU와 주기억장치 사이에 물리적으로 존재하는 버퍼 형태의 고속의 기억장치를 말한다. (통상, 컴퓨터 메모리 버퍼를 지칭)</li>\n</ul>\n</li>\n<li>사용 목적<ul>\n<li>CPU와 주기억장치 사이의 속도의 차이를 완화 (메모리 읽기 속도 개선용)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"쿠키-Cookie\"><a href=\"#쿠키-Cookie\" class=\"headerlink\" title=\"쿠키 (Cookie)\"></a>쿠키 (Cookie)</h3><ul>\n<li>개념<ul>\n<li>인터넷 웹 상에서 상태정보를 클라이언트측(인터넷 웹브라우저)에 저장하여, 서버측에서 필요할 때마다 지속성있게 활용하고자 할 때 사용한다. (클라이언트 로컬에 저장되는 키와 값이 들어있는 파일)</li>\n</ul>\n</li>\n<li>사용 목적<ul>\n<li>HTTP의 비연결(Connectionless)과 무상태(Stateless)을 보완</li>\n<li>웹 브라우저에 서버측에 있는 상태값들을 저장할 수 있게하도록 하여 사용자에 대한 지속적인 상태감시 및 상태참조를 한다.</li>\n</ul>\n</li>\n<li>쿠키 저장<ul>\n<li>웹 서버는, HTTP 헤더 내 Set-Cookie:란에 셋팅할 쿠키 관련 정보를 실려 보낸다.</li>\n<li>웹 브라우저는, 쿠키를 도메인 서버 이름으로 정렬된 쿠키 디렉토리에 저장한다.</li>\n<li>쿠키 구성요소</li>\n<li>쿠키의 이름(name)</li>\n<li>쿠키의 값(value)</li>\n<li>쿠키의 만료시간(Expires)</li>\n<li>쿠키를 전송할 도메인 이름(Domain)</li>\n<li>쿠키를 전송할 경로(Path)</li>\n<li>보안 연결 여부(Secure)</li>\n<li>HttpOnly 여부(HttpOnly)</li>\n</ul>\n</li>\n<li>동작방식<br><a href=\"https://user-images.githubusercontent.com/62123161/116166199-72be1880-a738-11eb-9d98-9c81fbc1cbba.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/116166199-72be1880-a738-11eb-9d98-9c81fbc1cbba.png\" alt=\"image\"></a></li>\n</ul>\n<p>1) 웹브라우저가 서버에 요청<br>2) 상태를 유지하고 싶은 값을 쿠키(cookie)로 생성<br>3) 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set−Cookie: id=doy</span><br></pre></td></tr></table></figure></div>\n<p>4) 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cookie: id=doy</span><br></pre></td></tr></table></figure></div>\n<p>5) 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인한 후 응답</p>\n<h3 id=\"세션-Session\"><a href=\"#세션-Session\" class=\"headerlink\" title=\"세션(Session)\"></a>세션(Session)</h3><ul>\n<li>개념<ul>\n<li>일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.</li>\n<li>즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다.</li>\n</ul>\n</li>\n<li>동작 방식<br><a href=\"https://user-images.githubusercontent.com/62123161/116166282-a39e4d80-a738-11eb-98e5-c2ade3366934.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/116166282-a39e4d80-a738-11eb-98e5-c2ade3366934.png\" alt=\"image\"></a></li>\n</ul>\n<p>1) 웹브라우저가 서버에 요청<br>2) 서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함<br>3) 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 Session ID를 포함해서 전송<br>쿠키에 Session ID를 JSESSIONID 라는 이름으로 저장</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set−Cookie: JSESSIONID=xslei13f</span><br></pre></td></tr></table></figure></div>\n<p>4) 웹브라우저는 이후 웹브라우저를 닫기까지 다음 요청 때 부여된 Session ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cookie: JSESSIONID=xslei13f</span><br></pre></td></tr></table></figure></div>\n<p>5) 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답</p>\n<h3 id=\"쿠키와-세션의-차이점\"><a href=\"#쿠키와-세션의-차이점\" class=\"headerlink\" title=\"쿠키와 세션의 차이점\"></a>쿠키와 세션의 차이점</h3><ul>\n<li>저장 위치<ul>\n<li>쿠키 : 클라이언트</li>\n<li>세션 : 서버</li>\n</ul>\n</li>\n<li>보안<ul>\n<li>쿠키 : 클라이언트에 저장되므로 보안에 취약하다.</li>\n<li>세션 : 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.</li>\n</ul>\n</li>\n<li>라이프사이클<ul>\n<li>쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.</li>\n<li>세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.</li>\n</ul>\n</li>\n<li>속도<ul>\n<li>쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.</li>\n<li>세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JWT-AccessToken\"><a href=\"#JWT-AccessToken\" class=\"headerlink\" title=\"JWT(AccessToken)\"></a>JWT(AccessToken)</h2><ul>\n<li>구성 요소<ul>\n<li>Header : 암호화할 방식(alg), 타입(type) 등</li>\n<li>Payload : 서버에서 보낼 데이터가 들어갑니다. 일반적으로 유저의 고유 ID값, 유효기간이 들어갑니다.</li>\n<li>Verify Signature : Base64 방식으로 인코딩한 Header,payload 그리고 SECRET KEY를 더한 후 서명됩니다.</li>\n</ul>\n</li>\n<li>최종Return값<ul>\n<li>Encoded Header + “.” + Encoded Payload + “.” + Verify Signature</li>\n</ul>\n</li>\n<li>Flow Chart<br><a href=\"https://user-images.githubusercontent.com/62123161/116166427-f37d1480-a738-11eb-8f77-b9d69d594f3c.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/116166427-f37d1480-a738-11eb-8f77-b9d69d594f3c.png\" alt=\"image\"></a></li>\n</ul>\n<ol>\n<li>사용자가 로그인을 한다.</li>\n<li>서버에서는 계정정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 넣습니다.</li>\n<li>JWT 토큰의 유효기간을 설정합니다.</li>\n<li>암호화할 SECRET KEY를 이용해 ACCESS TOKEN을 발급합니다.</li>\n<li>사용자는 Access Token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보냅니다.</li>\n<li>서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작 여부, 유효기간을 확인합니다.</li>\n<li>검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져옵니다.  </li>\n</ol>\n<h3 id=\"세션-쿠키와-JWT의-차이점\"><a href=\"#세션-쿠키와-JWT의-차이점\" class=\"headerlink\" title=\"세션/쿠키와 JWT의 차이점\"></a>세션/쿠키와 JWT의 차이점</h3><ul>\n<li>세션/쿠키 : 저장소에 유저의 정보를 넣음</li>\n<li>JWT : 토큰안에 유저정보를 넣음. 대신, 인증을 위해 암호화를 함.</li>\n</ul>\n<h2 id=\"별첨\"><a href=\"#별첨\" class=\"headerlink\" title=\"별첨\"></a>별첨</h2><ol>\n<li>NodeJS에서 body-parser 왜쓰는지?</li>\n</ol>\n<ul>\n<li><p>Express 버전 확인을 위해 (npm list -g) 명령어를 활용하거나, package lock.json 을 활용하면 된다.</p>\n</li>\n<li><p>Express 4.16.0 이하버전에서는 body-parser가 필요로 하지만, 이상의 버전에서는 app.use(express.json()) 으로 파싱이 가능하다.</p>\n</li>\n<li><p>또한, querystring 모듈을 활용할 수도 있다.</p>\n</li>\n</ul>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var qs = require(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">function</span> (request, response) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request.method == <span class=\"string\">'POST'</span>) &#123;</span><br><span class=\"line\">        var body = <span class=\"string\">''</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        request.on(<span class=\"string\">'data'</span>, <span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">            body += data;</span><br><span class=\"line\"> </span><br><span class=\"line\">            // Too much POST data, <span class=\"built_in\">kill</span> the connection!</span><br><span class=\"line\">            // 1e6 === 1 * Math.pow(10, 6) === 1 * 1000000 ~~~ 1MB</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (body.length &gt; 1e6)</span><br><span class=\"line\">                request.connection.destroy();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        request.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">            var post = qs.parse(body);</span><br><span class=\"line\">            // use post[<span class=\"string\">'blah'</span>], etc.</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>Header 정보 획득방법</li>\n</ol>\n<ul>\n<li><dl><dt>일단, npm모듈을 활용하는 방법이 있다.</dt><dd>npm install parse-headers</dd></dl></li>\n<li><p>input</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var parse = require(<span class=\"string\">'./parse-headers'</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  , headers = [</span><br><span class=\"line\">        <span class=\"string\">'Date: Sun, 17 Aug 2014 16:24:52 GMT'</span></span><br><span class=\"line\">      , <span class=\"string\">'Content-Type: text/html; charset=utf-8'</span></span><br><span class=\"line\">      , <span class=\"string\">'Transfer-Encoding: chunked'</span></span><br><span class=\"line\">      , <span class=\"string\">'X-Custom-Header: beep'</span></span><br><span class=\"line\">      , <span class=\"string\">'X-Custom-Header: boop'</span></span><br><span class=\"line\">    ].join(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">console.log(parse(headers))</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>output</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; date: <span class=\"string\">'Sun, 17 Aug 2014 16:24:52 GMT'</span>,</span><br><span class=\"line\">  <span class=\"string\">'content-type'</span>: <span class=\"string\">'text/html; charset=utf-8'</span>,</span><br><span class=\"line\">  <span class=\"string\">'transfer-encoding'</span>: <span class=\"string\">'chunked'</span>,</span><br><span class=\"line\">  <span class=\"string\">'x-custom-header'</span>: [ <span class=\"string\">'beep'</span>, <span class=\"string\">'boop'</span> ] &#125;</span><br></pre></td></tr></table></figure></div>\n</li>\n</ul>\n<ol start=\"3\">\n<li>HTTP 통신상 전문이 어떻게 타고 들어가는지?<br><a href=\"https://user-images.githubusercontent.com/62123161/116166596-5078ca80-a739-11eb-8f04-bec473a07090.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/116166596-5078ca80-a739-11eb-8f04-bec473a07090.png\" alt=\"image\"></a></li>\n</ol>\n<p>(IP/Port) or(DNS) 를 통해서 API서버로 요청이 들어온걸로 가정하면,</p>\n<p>1) 최초 app.js내에서 Express내 application.js handler 로 진입.(Default Configuration은 기본적으로 수행되니 생략)<br>2) 핸들러에서 라우터를 확인하고 HTTP Method를 확인한 뒤, Layer Stack을 수정해서 적용하고 Layer로 데이터를 보냄.<br>3) Layer는 여러 MiddleWare를 사용하며, (proto.process_params)에서 Req, Res 데이터들을 각각 분류하여 저장 및 생성.<br>4) Layer내에서 모두 셋팅이 끝나면 Router로 해당 데이터를 보냄.<br>5) 사용자가 요청한 데이터를 req에 받을 수 있고, Method를 통해 res데이터를 주는 것을 미리 Layer에서 셋팅된 res로 셋팅하여 내보낼 수 있음.</p>\n","text":"통신 MethodGET: 지정된 리소스(URI)를 요청POST: 서버가 클라이언트의 폼 입력 필드 데이터의 수락을 요청. 클라이언트는 서버로 HTTP Body에 Data를 전송HEAD: 문서의 헤더 정보만 요청하며, 응답데이터(body)를 받지 않는다","link":"","raw":null,"photos":[],"categories":[{"name":"web","slug":"web","count":1,"path":"api/categories/web.json"}],"tags":[{"name":"base","slug":"base","count":1,"path":"api/tags/base.json"},{"name":"HTTP","slug":"HTTP","count":1,"path":"api/tags/HTTP.json"}]},{"title":"CouchBase","slug":"CouchBase","date":"2021-04-22T03:36:33.000Z","updated":"2021-04-22T03:36:33.880Z","comments":true,"pin":null,"path":"api/articles/CouchBase.json","excerpt":"","keywords":null,"cover":null,"content":"","text":"","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"Redis","slug":"Redis","date":"2021-04-20T01:26:57.000Z","updated":"2021-04-22T08:16:31.128Z","comments":true,"pin":null,"path":"api/articles/Redis.json","excerpt":"","keywords":null,"cover":"https://user-images.githubusercontent.com/62123161/115353865-f8e7d580-a1f3-11eb-8e26-b0b4ee5ec8e5.png","content":"<h2 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h2><ul>\n<li>인메모리 Key-Value형 데이터베이스.</li>\n<li>오픈소스</li>\n<li>data structure 지원<blockquote>\n<p>Strings, set, hash, list<br>sorted-set(랭킹시스템 할때 좋음) But, 데이터 100만건 넘어가면 느려짐(초당 백만건 순회)<br>Hyperlog, bitmap, geospatial index<br>Stream</p>\n</blockquote>\n</li>\n<li>싱글스레드 : v4.0부터는 4개의 Thread를 가지지만, 메인스레드 한개만 돌고 나머지는 유휴상태(sub thread)에 있다가 메인스레드에 문제가 생기면 메인스레드가 됨.</li>\n<li>속도가 빠름.</li>\n</ul>\n<h2 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h2><p><a href=\"https://gofnrk.tistory.com/35\" target=\"_blank\" rel=\"noopener\">https://gofnrk.tistory.com/35</a></p>\n<ul>\n<li>위 주소를 통해 설치를 하면 되며, 별다른 설정없이도 기본기능은 사용할 수 있음.</li>\n</ul>\n<h2 id=\"CLI\"><a href=\"#CLI\" class=\"headerlink\" title=\"CLI\"></a>CLI</h2><ul>\n<li>Windows 기준</li>\n<li>설치폴더(C:\\Program Files\\Redis) 내 redis-cli.exe 를 통하여 Command를 날릴 수 있음.<br><a href=\"https://user-images.githubusercontent.com/62123161/115353865-f8e7d580-a1f3-11eb-8e26-b0b4ee5ec8e5.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/115353865-f8e7d580-a1f3-11eb-8e26-b0b4ee5ec8e5.png\" alt=\"image\"></a></li>\n</ul>\n<h2 id=\"사용시-주의사항\"><a href=\"#사용시-주의사항\" class=\"headerlink\" title=\"사용시 주의사항\"></a>사용시 주의사항</h2><ul>\n<li>메모리 관리<ol>\n<li>physical memory 이상을 사용하면 swap 메모리를 사용(swap 사용하면 메모리 page 접근시마다 읽고 쓰기 때문에 엄청 느려짐)</li>\n<li>적은 메모리 사용하는 instance 여러개가 안전</li>\n<li>큰 메모리일시 elastic cache 쓰면 상관없음(걔가 알아서 관리해줌)</li>\n<li>메모리 파편화<ul>\n<li>실제로 메모리 파편화가 많이 발생함</li>\n<li>jemlloc 버전에 따라서 다르게 파편화가 발생<ul>\n<li>jemlloc 4.x 대 부터 메모리 파편화 줄이기 위한 jemalloc에 힌트를 주는 기능이 들어감</li>\n<li>jemlloc 3.x 버전은 used memory 2GB라고 나오지만 실제론 11GB RSS를 사용하는 경우가 자주 발생함</li>\n</ul>\n</li>\n<li>다양한 사이즈를 가지는 데이터보단 유사크기의 데이터를 가지는 경우가 유리함</li>\n</ul>\n</li>\n<li>메모리 부족시?<ul>\n<li>장비 마이그레이션<ul>\n<li>메모리 빡빡하면 마이그레이션중 문제생길수도 있다 넉넉하게 하자</li>\n</ul>\n</li>\n<li>있는 데이터 줄이기<ul>\n<li>특정 데이터를 줄일때 이미 swap 사용중이라면 프로세스 재시작 해야됨</li>\n</ul>\n</li>\n<li>메모리를 줄이기위한 설정<ul>\n<li>Collection<ul>\n<li>Hash -&gt; HashTable 하나 더 사용</li>\n<li>Sorted Set -&gt; Skiplist와 HashTable 이용</li>\n<li>Set -&gt; HashTable 사용</li>\n<li>위의 자료구조들은 메모리 많이 사용함</li>\n</ul>\n</li>\n<li>Ziplist 이용<ul>\n<li>인메모리 특성상 적은 개수(100만개 이하)라면 선형탐색이 정말 빠름</li>\n<li>게다가 ziplist는 기존 자료구조보다 메모리를 적게 먹음!</li>\n<li>그러니 List, hash, sorted set 등을 ziplist로 대체하자<ul>\n<li>hash-max-ziplist-entries, hash-max-ziplist-value</li>\n<li>list-max-ziplist-size, list-max-ziplist-value</li>\n<li>zset-max-ziplist-entries, zset-max-ziplist-value</li>\n</ul>\n</li>\n<li>만약 설정갯수 오버하면 원래 설정 구조로 바뀌게됨(n개 이상이면 원래 hash로 돌아감.. 이런식)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>O(n) 관련 명령어 조심하자!<ol>\n<li>오래걸리는 대표적인 O(N) 명령들[KEYS, FLUSHALL, FLUSHDB, Delete Collections, Get All Collections]<ul>\n<li>싱글스레드기에 시간을 길게잡는 명령어들은 위험하다.</li>\n<li>Key가 백만개 이상인데 Key 명령을 사용하는 경우</li>\n<li>아이템이 몇만개 든 hash, sorted set, set에서 모든 데이터를 가져오는 경우</li>\n<li>spring security oauth redis tokenStore 문제</li>\n</ul>\n</li>\n<li>대안<ul>\n<li>KEYS -&gt; Scan<ul>\n<li>scan 명령으로 하나의 긴 명령을 짧은 여러번의 명령으로 바꿈</li>\n</ul>\n</li>\n<li>Collection의 모든 아이템을 가져와야 할때<ul>\n<li>Collection 일부만 가져오거나</li>\n<li>큰 Collection을 작은 여러개의 Collection으로 나눠서 저장</li>\n<li>Userranks -&gt; Userrank1, Userrank2, Userrank3</li>\n<li>개당 몇천개 안쪽으로 저장하는게 좋음</li>\n</ul>\n</li>\n<li>Spring security oauth RedisTokenStore 이슈<ul>\n<li>스프링 시큐리티 레디스 토큰조회를 O(N) 으로 하고있었음</li>\n<li>100만개 넘어가면 검색/삭제 한번 하는데에 1초씩 걸렸음</li>\n<li>O(N) -&gt; O(1) 로 고쳐짐, 따라서 지금은 괜찮음</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"별첨-Redis-Setting\"><a href=\"#별첨-Redis-Setting\" class=\"headerlink\" title=\"별첨 : Redis Setting\"></a>별첨 : Redis Setting</h2><ol>\n<li><p>General</p>\n<ul>\n<li>databases</li>\n<li>logfile</li>\n<li>pidfile</li>\n<li>daemonize</li>\n<li>bind</li>\n<li>port</li>\n<li>tcp-backlog</li>\n</ul>\n</li>\n<li><p>AOF(Append Only File)</p>\n<ul>\n<li>aof-load-truncated    </li>\n<li>aof-rewrite-incremental-fsync</li>\n<li>appendfsync</li>\n<li>appendonly</li>\n<li>auto-aof-rewrite-min-size</li>\n<li>auto-aof-rewrite-percentage</li>\n<li>no-appendfsync-on-rewrite</li>\n</ul>\n</li>\n<li><p>RDB</p>\n<ul>\n<li>dbfilename</li>\n<li>rdbchecksum</li>\n<li>rdbcompression</li>\n<li>save</li>\n<li>stop-writes-on-bgsave-error</li>\n</ul>\n</li>\n<li><p>Replication</p>\n<ul>\n<li>slaveof    </li>\n<li>slave-read-only    </li>\n<li>slave-priority</li>\n<li>slave-serve-stale-data</li>\n<li>repl-backlog-size</li>\n<li>repl-backlog-ttl</li>\n<li>repl-disable-tcp-nodelay</li>\n<li>repl-diskless-sync</li>\n<li>repl-diskless-sync-delay</li>\n<li>repl-ping-slave-period</li>\n<li>repl-timeout</li>\n<li>min-slaves-max-lag</li>\n<li>min-slaves-to-write</li>\n</ul>\n</li>\n<li><p>Memory</p>\n<ul>\n<li>maxmemory</li>\n<li>maxmemory-policy</li>\n<li>maxmemory-samples</li>\n</ul>\n</li>\n<li><p>Cluster</p>\n<ul>\n<li>cluster-migration-barrier</li>\n<li>cluster-node-timeout</li>\n<li>cluster-require-full-coverage</li>\n<li>cluster-slave-validity-factor</li>\n</ul>\n</li>\n<li><p>Etc</p>\n<ul>\n<li>dir</li>\n<li>loglevel</li>\n<li>tcp-keepalive</li>\n<li>timeout</li>\n<li>client-output-buffer-limit</li>\n<li>maxclients</li>\n<li>list-max-ziplist-entries</li>\n<li>list-max-ziplist-value</li>\n<li>hash-max-ziplist-entries</li>\n<li>hash-max-ziplist-value</li>\n<li>set-max-intset-entries</li>\n<li>zset-max-ziplist-entries</li>\n<li>zset-max-ziplist-value</li>\n<li>activerehashing</li>\n<li>hll-sparse-max-bytes</li>\n<li>hz</li>\n<li>latency-monitor-threshold</li>\n<li>requirepass</li>\n<li>masterauth</li>\n<li>notify-keyspace-events</li>\n<li>slowlog-log-slower-than</li>\n<li>slowlog-max-len</li>\n<li>unixsocket</li>\n<li>unixsocketperm</li>\n<li>lua-time-limit</li>\n<li>watchdog-period</li>\n</ul>\n</li>\n</ol>\n<p>관련출처 : <a href=\"https://sehajyang.github.io/2019/12/11/how-to-operate-redis/\" target=\"_blank\" rel=\"noopener\">https://sehajyang.github.io/2019/12/11/how-to-operate-redis/</a></p>\n","text":"개요인메모리 Key-Value형 데이터베이스.오픈소스data structure 지원Strings, set, hash, list<br>sorted-set(랭킹시스템 할때 좋음) But, 데이터 100만건 넘어가면 느려짐(초당 백만건 순회)<br>Hype","link":"","raw":null,"photos":[],"categories":[{"name":"aws","slug":"aws","count":19,"path":"api/categories/aws.json"}],"tags":[{"name":"Redis","slug":"Redis","count":1,"path":"api/tags/Redis.json"},{"name":"key","slug":"key","count":1,"path":"api/tags/key.json"},{"name":"value","slug":"value","count":1,"path":"api/tags/value.json"},{"name":"inmemory","slug":"inmemory","count":1,"path":"api/tags/inmemory.json"},{"name":"db","slug":"db","count":1,"path":"api/tags/db.json"}]},{"title":"Container-Lambda","slug":"Container-Lambda","date":"2021-03-26T03:46:18.000Z","updated":"2021-03-30T07:30:14.098Z","comments":true,"pin":null,"path":"api/articles/Container-Lambda.json","excerpt":"","keywords":null,"cover":"https://user-images.githubusercontent.com/56995911/112574344-69881600-8e31-11eb-806d-741718653ca7.png","content":"<h2 id=\"컨테이너의-개념\"><a href=\"#컨테이너의-개념\" class=\"headerlink\" title=\"컨테이너의 개념\"></a>컨테이너의 개념</h2><ul>\n<li><p>선박의 컨테이너처럼 프로세스가 사용하는 자원을 격리하는 것.<br><a href=\"https://user-images.githubusercontent.com/56995911/112574344-69881600-8e31-11eb-806d-741718653ca7.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112574344-69881600-8e31-11eb-806d-741718653ca7.png\" alt=\"image\"></a></p>\n</li>\n<li><p>가상머신과 마찬가지로 애플리케이션을 관련 라이브러리 및 종속 항목과 함께 패키지로 묶어 소프트웨어 서비스를 위한 격리환경에서 구동</p>\n</li>\n<li><p>장점</p>\n<ul>\n<li>가벼움<ul>\n<li>Request Traffic에 따라 추가배포가 가능.</li>\n<li>가상머신은 수 GB의 무거운 환경을 구성해야 하지만, Container는 GuestOS가 없으므로 MB단위의 구동환경을 가짐.</li>\n</ul>\n</li>\n<li>탄력성<ul>\n<li>운영체제(Linux, Windows 등), 가상머신, 로컬, 운영PC, 클라우드 등 어느 환경에서나 구동이 가능하므로 개발/배포가 쉬움.</li>\n</ul>\n</li>\n<li>유지 관리 효율<ul>\n<li>커널이 하나뿐이어서 업데이트/패치를 수행하면 전체적용이 되므로 효율적으로 유지관리 가능.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>도커의 작동순서<br><a href=\"https://user-images.githubusercontent.com/56995911/112584661-96412b00-8e3b-11eb-8274-900aeffd4ec2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112584661-96412b00-8e3b-11eb-8274-900aeffd4ec2.png\" alt=\"image\"></a></p>\n<ol>\n<li>코드개발</li>\n<li>Dockerfile 생성</li>\n<li>Dockerfile Image 생성(핵심 : 코드를 이미지화 하여 배포)</li>\n<li>Container Orchestrator를 통한 배포</li>\n<li>Container run</li>\n<li>Container image Push</li>\n</ol>\n</li>\n<li><p>도커파일 예제</p>\n<ul>\n<li><a href=\"https://javacan.tistory.com/entry/docker-start-7-create-image-using-dockerfile\" target=\"_blank\" rel=\"noopener\">https://javacan.tistory.com/entry/docker-start-7-create-image-using-dockerfile</a></li>\n</ul>\n</li>\n<li><p>[Container 시리즈] 02. Docker사용법 Docker Basic Command (osci.kr)(<a href=\"https://tech.osci.kr/2020/03/03/91690192/\" target=\"_blank\" rel=\"noopener\">https://tech.osci.kr/2020/03/03/91690192/</a>)</p>\n</li>\n</ul>\n<h2 id=\"Lambda-작성-및-시연\"><a href=\"#Lambda-작성-및-시연\" class=\"headerlink\" title=\"Lambda 작성 및 시연\"></a>Lambda 작성 및 시연</h2><h3 id=\"설정\"><a href=\"#설정\" class=\"headerlink\" title=\"설정\"></a>설정</h3><p><a href=\"https://user-images.githubusercontent.com/56995911/112585029-67778480-8e3c-11eb-9ce6-2a4bfd4db374.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112585029-67778480-8e3c-11eb-9ce6-2a4bfd4db374.png\" alt=\"image\"></a><br><a href=\"https://user-images.githubusercontent.com/56995911/112585035-6b0b0b80-8e3c-11eb-80bf-7961f577cf28.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112585035-6b0b0b80-8e3c-11eb-80bf-7961f577cf28.png\" alt=\"image\"></a></p>\n<ul>\n<li>위와 같은 화면이 나오기 위해서는 AWS Sam(다람쥐) 설치하여야 한다.</li>\n<li>Configure-Plugins 내에서 AWS ToolKit을 설치.</li>\n<li>또한, Docker는 필수. </li>\n</ul>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><p><a href=\"https://user-images.githubusercontent.com/56995911/112586776-b672e900-8e3f-11eb-8253-dc407c41a8b2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112586776-b672e900-8e3f-11eb-8253-dc407c41a8b2.png\" alt=\"image\"></a><br><a href=\"https://user-images.githubusercontent.com/56995911/112586785-bbd03380-8e3f-11eb-9389-d5abb4dd7de1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112586785-bbd03380-8e3f-11eb-9389-d5abb4dd7de1.png\" alt=\"image\"></a><br><a href=\"https://user-images.githubusercontent.com/56995911/112586790-bf63ba80-8e3f-11eb-8c2c-46beccfc5e15.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112586790-bf63ba80-8e3f-11eb-8c2c-46beccfc5e15.png\" alt=\"image\"></a><br><a href=\"https://user-images.githubusercontent.com/56995911/112586797-c1c61480-8e3f-11eb-94f6-c9fe9e3d01fa.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112586797-c1c61480-8e3f-11eb-94f6-c9fe9e3d01fa.png\" alt=\"image\"></a><br><a href=\"https://user-images.githubusercontent.com/56995911/112586804-c4286e80-8e3f-11eb-84bf-9687952ef1de.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112586804-c4286e80-8e3f-11eb-84bf-9687952ef1de.png\" alt=\"image\"></a></p>\n<h3 id=\"Node-Js\"><a href=\"#Node-Js\" class=\"headerlink\" title=\"Node.Js\"></a>Node.Js</h3><p><a href=\"https://user-images.githubusercontent.com/56995911/112586925-f8039400-8e3f-11eb-9947-ed02d7fad936.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112586925-f8039400-8e3f-11eb-9947-ed02d7fad936.png\" alt=\"image\"></a><br><a href=\"https://user-images.githubusercontent.com/56995911/112586929-fa65ee00-8e3f-11eb-82ce-d0abf9405385.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112586929-fa65ee00-8e3f-11eb-82ce-d0abf9405385.png\" alt=\"image\"></a><br><a href=\"https://user-images.githubusercontent.com/56995911/112586934-fcc84800-8e3f-11eb-9bf5-c5e2859151f1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112586934-fcc84800-8e3f-11eb-9bf5-c5e2859151f1.png\" alt=\"image\"></a><br><a href=\"https://user-images.githubusercontent.com/56995911/112586939-ff2aa200-8e3f-11eb-96dc-83597e3839db.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112586939-ff2aa200-8e3f-11eb-96dc-83597e3839db.png\" alt=\"image\"></a></p>\n","text":"컨테이너의 개념선박의 컨테이너처럼 프로세스가 사용하는 자원을 격리하는 것.<br> [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"aws","slug":"aws","count":19,"path":"api/categories/aws.json"}],"tags":[{"name":"AWS","slug":"AWS","count":20,"path":"api/tags/AWS.json"},{"name":"Container","slug":"Container","count":1,"path":"api/tags/Container.json"},{"name":"Lambda","slug":"Lambda","count":2,"path":"api/tags/Lambda.json"}]},{"title":"ECS-Fargate","slug":"ECS-Fargate","date":"2021-03-26T02:45:47.000Z","updated":"2021-03-26T03:04:01.118Z","comments":true,"pin":null,"path":"api/articles/ECS-Fargate.json","excerpt":"","keywords":null,"cover":"https://user-images.githubusercontent.com/56995911/112570172-e498fe80-8e28-11eb-9ad5-26085f9e5a9e.png","content":"<h2 id=\"미리-드리는-말\"><a href=\"#미리-드리는-말\" class=\"headerlink\" title=\"미리 드리는 말\"></a>미리 드리는 말</h2><ul>\n<li>예제로 생성되는 컨테이너는 Public Docker File 이며, ECS에서 각 서비스별로 사용할때는 ECR에 Container Image를 등록하여 활용하는 것이 좋음.</li>\n<li>컨테이너 파일을 미리 만들어 둔 것이 있다면 해당 컨테이너를 사용해도 아래 예제는 정상적으로 돌아감.<br>(단, Port 설정 / Bound 설정 등 네트워크 설정들은 해주어야 함)</li>\n</ul>\n<h3 id=\"1-Cluster-생성\"><a href=\"#1-Cluster-생성\" class=\"headerlink\" title=\"1. Cluster 생성\"></a>1. Cluster 생성</h3><p><a href=\"https://user-images.githubusercontent.com/56995911/112570172-e498fe80-8e28-11eb-9ad5-26085f9e5a9e.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112570172-e498fe80-8e28-11eb-9ad5-26085f9e5a9e.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112570232-04302700-8e29-11eb-9957-2eed9e2840a9.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112570232-04302700-8e29-11eb-9957-2eed9e2840a9.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112570272-1611ca00-8e29-11eb-86f2-613946650c95.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112570272-1611ca00-8e29-11eb-86f2-613946650c95.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112570312-27f36d00-8e29-11eb-8e64-39ca72f758ab.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112570312-27f36d00-8e29-11eb-8e64-39ca72f758ab.png\" alt=\"image\"></a></p>\n<ul>\n<li>클러스터는 ECS의 기본단위이며, Task들이 돌아갈 수 있는 일종의 EC2인스턴스같은 환경이라고 이해하면 됨.</li>\n<li>따라서, 아무것도 없는 EC2를 먼저 띄우듯이 빈 껍데기인 Cluster를 먼저 생성해줌.</li>\n</ul>\n<h3 id=\"2-Task-Definition-설정\"><a href=\"#2-Task-Definition-설정\" class=\"headerlink\" title=\"2. Task Definition 설정\"></a>2. Task Definition 설정</h3><p><a href=\"https://user-images.githubusercontent.com/56995911/112570468-7143bc80-8e29-11eb-895a-9cacc52a8bc1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112570468-7143bc80-8e29-11eb-895a-9cacc52a8bc1.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112570506-80c30580-8e29-11eb-93a5-e9eb98e71cd0.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112570506-80c30580-8e29-11eb-93a5-e9eb98e71cd0.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112570585-a3edb500-8e29-11eb-86c3-26949eec9f33.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112570585-a3edb500-8e29-11eb-86c3-26949eec9f33.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112570604-b1a33a80-8e29-11eb-86b2-277ae062f59e.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112570604-b1a33a80-8e29-11eb-86b2-277ae062f59e.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112570638-c41d7400-8e29-11eb-8b46-8f1347984181.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112570638-c41d7400-8e29-11eb-8b46-8f1347984181.png\" alt=\"image\"></a></p>\n<ul>\n<li>실제 Task들이 어떻게 구동할지 어떤환경에서 구동이 되는지를 설정해주는 것.</li>\n<li>Task Definition 은 ECS에 종속적이지 않음.</li>\n<li>Docker Example : docker.io/library/nginx</li>\n<li>예제샘플 도커 주소 : <a href=\"https://hub.docker.com/search?q=nginx&amp;type=image\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/search?q=nginx&amp;type=image</a></li>\n</ul>\n<h3 id=\"3-서비스-생성\"><a href=\"#3-서비스-생성\" class=\"headerlink\" title=\"3. 서비스 생성\"></a>3. 서비스 생성</h3><p><a href=\"https://user-images.githubusercontent.com/56995911/112571035-89680b80-8e2a-11eb-9a68-387db7307657.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112571035-89680b80-8e2a-11eb-9a68-387db7307657.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112571055-971d9100-8e2a-11eb-951c-10ec489422c5.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112571055-971d9100-8e2a-11eb-951c-10ec489422c5.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112571083-a43a8000-8e2a-11eb-9551-cc284e26431d.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112571083-a43a8000-8e2a-11eb-9551-cc284e26431d.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112571113-b4525f80-8e2a-11eb-8842-e2aedf23fcde.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112571113-b4525f80-8e2a-11eb-8842-e2aedf23fcde.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112571136-c16f4e80-8e2a-11eb-96a2-23d7c4a9d9c7.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112571136-c16f4e80-8e2a-11eb-96a2-23d7c4a9d9c7.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112571145-c9c78980-8e2a-11eb-9083-5ee82e568d03.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112571145-c9c78980-8e2a-11eb-9083-5ee82e568d03.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112571316-29259980-8e2b-11eb-8813-9c99f1bc322e.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112571316-29259980-8e2b-11eb-8813-9c99f1bc322e.png\" alt=\"image\"></a></p>\n<p><a href=\"https://user-images.githubusercontent.com/56995911/112571373-3c386980-8e2b-11eb-869e-8d040c97fb38.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112571373-3c386980-8e2b-11eb-869e-8d040c97fb38.png\" alt=\"image\"></a></p>\n<h3 id=\"4-테스트\"><a href=\"#4-테스트\" class=\"headerlink\" title=\"4. 테스트\"></a>4. 테스트</h3><ul>\n<li>public IP : 3.36.59.154 로 인터넷 접속하면 화면이 아래와 같이 뜸.<br><a href=\"https://user-images.githubusercontent.com/56995911/112571419-52462a00-8e2b-11eb-89d5-41961b23018c.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/112571419-52462a00-8e2b-11eb-89d5-41961b23018c.png\" alt=\"image\"></a></li>\n</ul>\n","text":"미리 드리는 말예제로 생성되는 컨테이너는 Public Docker File 이며, ECS에서 각 서비스별로 사용할때는 ECR에 Container Image를 등록하여 활용하는 것이 좋음.컨테이너 파일을 미리 만들어 둔 것이 있다면 해당 컨테이너를 사용","link":"","raw":null,"photos":[],"categories":[{"name":"aws","slug":"aws","count":19,"path":"api/categories/aws.json"}],"tags":[{"name":"AWS","slug":"AWS","count":20,"path":"api/tags/AWS.json"},{"name":"ECS","slug":"ECS","count":3,"path":"api/tags/ECS.json"},{"name":"Fargate","slug":"Fargate","count":1,"path":"api/tags/Fargate.json"}]},{"title":"Kinesis WebRTC","slug":"Kinesis-WebRTC","date":"2021-03-11T07:10:56.000Z","updated":"2021-03-11T07:58:37.628Z","comments":true,"pin":null,"path":"api/articles/Kinesis-WebRTC.json","excerpt":"","keywords":null,"cover":"https://user-images.githubusercontent.com/62123161/110749545-99a5b580-8284-11eb-8fad-54274432de3a.png","content":"<h2 id=\"WebRTC-가격비교\"><a href=\"#WebRTC-가격비교\" class=\"headerlink\" title=\"WebRTC 가격비교\"></a>WebRTC 가격비교</h2><p>WebRTC 기능을 사용하면 해당 월의 활성 상태인 신호 채널 수, 송수신된 신호 메시지 수 및 미디어 중계에 사용된 TURN 스트리밍 분에 따라 부과됩니다.</p>\n<p>해당 월 기간에 언제든지 디바이스 또는 애플리케이션이 신호 채널에 연결되면 신호 채널은 활성으로 간주됩니다. TURN 스트리밍 분은 1분 간격으로 계량됩니다.</p>\n<p><a href=\"https://user-images.githubusercontent.com/62123161/110749545-99a5b580-8284-11eb-8fad-54274432de3a.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/110749545-99a5b580-8284-11eb-8fad-54274432de3a.png\" alt=\"image\"></a></p>\n<h2 id=\"WebRTC-검토\"><a href=\"#WebRTC-검토\" class=\"headerlink\" title=\"WebRTC 검토\"></a>WebRTC 검토</h2><h3 id=\"OverView\"><a href=\"#OverView\" class=\"headerlink\" title=\"OverView\"></a>OverView</h3><ul>\n<li>Official Site : <a href=\"https://webrtc.org\" target=\"_blank\" rel=\"noopener\">https://webrtc.org</a></li>\n<li>W3C Specification : <a href=\"https://w3c.github.io/webrtc-pc/\" target=\"_blank\" rel=\"noopener\">https://w3c.github.io/webrtc-pc/</a> (latest published version : WebRTC 1.0: Real-Time Communication Between Browsers (w3.org))</li>\n<li>Associated Test Suite (Browser base)</li>\n<li>wpt/webrtc at master · web-platform-tests/wpt · GitHub</li>\n<li>Web 기반, Peer to Peer 실시간 비디오/오디오 통신 Specification</li>\n</ul>\n<p><a href=\"https://user-images.githubusercontent.com/62123161/110749938-189aee00-8285-11eb-9227-93f4fc395e61.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/110749938-189aee00-8285-11eb-9227-93f4fc395e61.png\" alt=\"image\"></a></p>\n<ul>\n<li><p>각종 브라우저에서 기본 WebRTC Framework 을 지원하고 , 브라우저를 통해서는 별다른 설정없이 1:1 실시간 화상통화 기능은 즉시 사용가능함.<br>&nbsp;&nbsp; - 브라우저 자체엔진에서 WebRTC Framework 탑재.<br>&nbsp;&nbsp; - HTML 기반 API 제공하고 있음.<br>&nbsp;&nbsp; - OS or Browser Version 별 지원내역 ( ref&gt; wikipedia )<br>&nbsp;&nbsp;&nbsp;&nbsp; - Desktop Browser (MS-Edge 12+, Google Chrome 28+, Mozilla Firefox 22+, Safari 11+, Opera 18+, Vivaldi 1.9+)<br>&nbsp;&nbsp;&nbsp;&nbsp; - Android (Google Chrome 28+, Mozilla Firefox 24+, Opera Mobile 12+)<br>&nbsp;&nbsp;&nbsp;&nbsp; - Chrome OS / Firefox OS / BlackBerry 10<br>&nbsp;&nbsp;&nbsp;&nbsp; - iOS 11(MobileSafari/WebKit)<br>&nbsp;&nbsp;&nbsp;&nbsp; - Tizen 3.0</p>\n</li>\n<li><p>1:1 (Peer to Peer) 동작 지원이 기본 사양.</p>\n</li>\n<li><p>1:N 및 방화벽을 경유하는 영상/음성 전송을 제공하기 위해서는 별도의 서버(TURN/STUN) 를 구축 필요.<br>&nbsp;&nbsp; - 대부분의 방화벽모델은 Port Forwarding Rule 설정을 통해 해결됨.<br>&nbsp;&nbsp; - 방화벽이 Symmetric NAT 인 경우 Outbound IP Address 가 달라지므로, 외부에서 접속할 방법이 없어져 동작 불가능.<br>&nbsp;&nbsp; Solution) TURN Relay  : Public Domain 에 Relay Server 를 두고 이를 통해 영상/음성 Data 를 Routing 하는 것으로 해결.</p>\n</li>\n</ul>\n<h3 id=\"Protocol-Stack\"><a href=\"#Protocol-Stack\" class=\"headerlink\" title=\"Protocol Stack\"></a>Protocol Stack</h3><ul>\n<li>WebRTC 기능 개발시 RTCPeerConnection , RTCDataChannel API 는 아래와 같이 구성됨.</li>\n<li>Secure 채널을 제공하기위해 ICE/STUN/TURN 위에 DTLS 를 사용.(Mandatory feature)</li>\n<li>UDP 특성상 congestion control , flow control reliability 를 제공하지 않음에 따라</li>\n<li>SRTP / SCTP 를 통한 Connection setup / Data Delivery 를 사용함.</li>\n</ul>\n<p><a href=\"https://user-images.githubusercontent.com/62123161/110750295-9ced7100-8285-11eb-82a8-affa6f8e55d4.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/110750295-9ced7100-8285-11eb-82a8-affa6f8e55d4.png\" alt=\"image\"></a></p>\n<h3 id=\"APIs\"><a href=\"#APIs\" class=\"headerlink\" title=\"APIs\"></a>APIs</h3><p>WebRTC 의 주요 구성요소는 각 Platform ( Browser 기반, Android 기반, iOS 기반 ) 별로 표준화된(유사한) API 를 제공하고,<br>이를 통해 각 Client Application 을 제작, 배포 가능.</p>\n<h4 id=\"Interfaces\"><a href=\"#Interfaces\" class=\"headerlink\" title=\"Interfaces\"></a>Interfaces</h4><ul>\n<li>getUserMedia<br>&nbsp;&nbsp; - Webcam/audio등의 사용권한 요청.</li>\n<li>RTCPeerConnection<br>&nbsp;&nbsp; - ICE agent 역할을 수행하는 Object, Signaling channel을 통해 획득한 sdp/ice candidate등을 등록하여, ICE gathering수행.<br>&nbsp;&nbsp; - RTCIceCanddiate/ RTCConfiguration 객체등을 사용함.<br>&nbsp;&nbsp; - Peer와 컨넥션 생성 후 미디어 전송을 위한 RTCRtpSender/RTCRtpReceiver/RTCRtpTransceiver등을 획득할 수 있음.<br>&nbsp;&nbsp; - addTrack을 이용해서 전송하고자 하는 미디어 트랙을 추가 할 수 있음<br>&nbsp;&nbsp; - createDataChennel을 통해서 데이터 전송을 위한 커넥션 생성가능. (채팅/파일전송등)</li>\n<li>RTCDataChannel</li>\n<li>RTCDataChannelEvent</li>\n<li>RTCSessionDescription<br>&nbsp;&nbsp; - SDP정보</li>\n<li>RTCStatsReport</li>\n<li>RTCIceCandidate<br>&nbsp;&nbsp; - ICE candidate정보</li>\n<li>RTCIceTransport<br>&nbsp;&nbsp; - ICE agent의 상태확인 가능/ gathering state/ local, remote candidates, 이 Agent의 role./ selected candidate pair등</li>\n<li>RTCPeerConnectionIceEvent</li>\n<li>RTCRtpSender<br>&nbsp;&nbsp; - 주어진 MediaStreamTrack의 전송을 제어 할 수 있음.<br>&nbsp;&nbsp; - MediaStreamTrack변경<br>&nbsp;&nbsp; - 전송상태 확인가능</li>\n<li>RTCRtpReceiver<br>&nbsp;&nbsp; - 수신중인 MediaStream의 미디어속성/TLS속성/상태 확인가능.</li>\n<li>RTCTrackEvent</li>\n<li>RTCSctpTransport</li>\n</ul>\n<h3 id=\"Service-Component\"><a href=\"#Service-Component\" class=\"headerlink\" title=\"Service Component\"></a>Service Component</h3><p>WebRTC Service 는 다음 세가지로 구성되고 서비스 목적에 따라 각 구성 요소별 별도 Configuration 이 필요</p>\n<ul>\n<li><p>WebRTC Gateway<br>WebRTC 의 Signaling 방식은 Web 방식임에 따라 각 Peer 간의 initial Connection 을 위해 WebServer 가 필요함.<br>node.js 또는 XHR 처리가 가능한 Server 로 구성필요.</p>\n</li>\n<li><p>WebRTC Client</p>\n</li>\n<li><p>TURN/STUN Server</p>\n</li>\n</ul>\n<h3 id=\"Testing-Flow\"><a href=\"#Testing-Flow\" class=\"headerlink\" title=\"Testing Flow?\"></a>Testing Flow?</h3><p><a href=\"https://user-images.githubusercontent.com/62123161/110750602-138a6e80-8286-11eb-8e75-6078530b7e56.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/110750602-138a6e80-8286-11eb-8e75-6078530b7e56.png\" alt=\"image\"></a></p>\n","text":"WebRTC 가격비교WebRTC 기능을 사용하면 해당 월의 활성 상태인 신호 채널 수, 송수신된 신호 메시지 수 및 미디어 중계에 사용된 TURN 스트리밍 분에 따라 부과됩니다.해당 월 기간에 언제든지 디바이스 또는 애플리케이션이 신호 채널에 연결되면","link":"","raw":null,"photos":[],"categories":[{"name":"aws","slug":"aws","count":19,"path":"api/categories/aws.json"}],"tags":[{"name":"AWS","slug":"AWS","count":20,"path":"api/tags/AWS.json"},{"name":"Kinesis","slug":"Kinesis","count":4,"path":"api/tags/Kinesis.json"},{"name":"WebRTC","slug":"WebRTC","count":1,"path":"api/tags/WebRTC.json"}]},{"title":"Fargate","slug":"Fargate","date":"2021-03-01T01:45:56.000Z","updated":"2021-02-23T01:50:19.654Z","comments":true,"pin":null,"path":"api/articles/Fargate.json","excerpt":"","keywords":null,"cover":null,"content":"<h3 id=\"Fargate란\"><a href=\"#Fargate란\" class=\"headerlink\" title=\"Fargate란?\"></a>Fargate란?</h3><ul>\n<li>ECS<sup>Elastic Container Service</sup> 의 하나의 옵션이었음.</li>\n<li>기존 ECS는 EC2의 인스턴스 클러스터를 관리, 사용률 모니터링 등을 사용자가 수행해야 했지만, EC2 자원관리를 AWS에 맡겨 서버의 프로비저닝이나 스케일링에 대해 생각하지 않고 컨테이너, Application에 집중해서 구축 할 수 있는 장점이 있음.</li>\n<li>서버를 관리하지 않는다는 관점에서 Lambda랑 비슷하기에 컨테이너버전의 Serverless라고 불리기도 함. (람다와 달리 성능, 시간제한같은게 없다.)</li>\n</ul>\n<h3 id=\"가격\"><a href=\"#가격\" class=\"headerlink\" title=\"가격?\"></a>가격?</h3><ul>\n<li>t2.Micro 보다 비싼편 ($0.00511USD/hour)</li>\n<li>다만, CPU를 0.25(1/4)로 사용이 가능하기에 어느정도 절약은 가능.</li>\n</ul>\n<h3 id=\"적용방법\"><a href=\"#적용방법\" class=\"headerlink\" title=\"적용방법\"></a>적용방법</h3><ol>\n<li>IAM 계정 생성</li>\n<li>도커 이미지 생성 및 ECR에 등록</li>\n</ol>\n<ul>\n<li>aws cli 환경설정</li>\n<li>Docker 이미지용 Application 작성</li>\n<li>ECR에 repository 생성</li>\n<li>ECR에 repository에 Docker Image 올리기</li>\n</ul>\n<ol start=\"3\">\n<li>작업 정의</li>\n</ol>\n<ul>\n<li>작업 정의 생성</li>\n<li>작업 정의에 컨테이너 추가</li>\n</ul>\n<ol start=\"4\">\n<li>클러스터 및 서비스 생성</li>\n</ol>\n<ul>\n<li>클러스터 생성</li>\n<li>서비스 생성</li>\n<li>서비스 확인</li>\n</ul>\n","text":"Fargate란?ECSElastic Container Service 의 하나의 옵션이었음.기존 ECS는 EC2의 인스턴스 클러스터를 관리, 사용률 모니터링 등을 사용자가 수행해야 했지만, EC2 자원관리를 AWS에 맡겨 서버의 프로비저닝이나 스케일링에","link":"","raw":null,"photos":[],"categories":[{"name":"aws","slug":"aws","count":19,"path":"api/categories/aws.json"}],"tags":[{"name":"AWS","slug":"AWS","count":20,"path":"api/tags/AWS.json"},{"name":"ECS","slug":"ECS","count":3,"path":"api/tags/ECS.json"},{"name":"fargate","slug":"fargate","count":1,"path":"api/tags/fargate.json"}]},{"title":"ECS","slug":"ECS","date":"2021-03-01T01:32:32.000Z","updated":"2021-03-26T02:45:30.947Z","comments":true,"pin":null,"path":"api/articles/ECS.json","excerpt":"","keywords":null,"cover":"https://user-images.githubusercontent.com/56995911/108791589-c68a7500-75c2-11eb-895d-07dc43f35c83.png","content":"<h3 id=\"ECSElastic-Container-Service란\"><a href=\"#ECSElastic-Container-Service란\" class=\"headerlink\" title=\"ECSElastic Container Service란 ?\"></a>ECS<sup>Elastic Container Service</sup>란 ?</h3><ul>\n<li>도커<sup>Docker</sup>는 응용프로그램들을 소프트웨어 컨테이너안에 배치시키고 이를 신속하게 구축, 테스트, 배포 가능한 소프트웨어 플랫폼</li>\n<li>컨테이너 가상화에 기반한 서비스</li>\n<li>엘라스틱 컨테이너 서비스<sup>Elastic Container Service</sup> 는 이런 Docker컨테이너를 관리해주는 오케스트레이션 도구.</li>\n<li>비슷한 오케스트레이션 도구로는 도커에서 만든 스웜<sup>Swarm</sup>, 구글<sup>Google</sup>의 노하우가 담겨있는 쿠버네티스<sup>Kubernetes</sup>, 하시코프의 노마드<sup>Nomad</sup> 등이 있음.</li>\n<li>Fargate 시작유형 / EC2 시작유형 으로 분리되어 있음.</li>\n</ul>\n<h3 id=\"ECSElastic-Container-Service사용시-이점\"><a href=\"#ECSElastic-Container-Service사용시-이점\" class=\"headerlink\" title=\"ECSElastic Container Service사용시 이점 ?\"></a>ECS<sup>Elastic Container Service</sup>사용시 이점 ?</h3><ul>\n<li>간단한 API 호출을 사용하여 컨테이너 기반 애플리케이션을 시작 및 중지할 수 있다.</li>\n<li>중앙 집중식 서비스를 사용하여 클러스터 상태를 확인할 수 있다</li>\n<li>다수의 친숙한 EC2 기능에 액세스할 수 있다.</li>\n<li>일관된 배포 및 구축 환경을 생성하고, 배치 및 ETL(Extract-Transform-Load) 워크로드를 관리 및 크기 조정하고, 마이크로 서비스 모델에 정교한 애플리케이션 아키텍처를 구축할 수 있다.</li>\n</ul>\n<h3 id=\"클러스터Cluster와-클러스터-인스턴스Cluster-Instance\"><a href=\"#클러스터Cluster와-클러스터-인스턴스Cluster-Instance\" class=\"headerlink\" title=\"클러스터Cluster와 클러스터 인스턴스Cluster Instance\"></a>클러스터<sup>Cluster</sup>와 클러스터 인스턴스<sup>Cluster Instance</sup></h3><p><a href=\"https://user-images.githubusercontent.com/56995911/108791589-c68a7500-75c2-11eb-895d-07dc43f35c83.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/108791589-c68a7500-75c2-11eb-895d-07dc43f35c83.png\" alt=\"image\"></a></p>\n<h4 id=\"클러스터Cluster\"><a href=\"#클러스터Cluster\" class=\"headerlink\" title=\"클러스터Cluster\"></a>클러스터<sup>Cluster</sup></h4><ul>\n<li>ECS의 가장 기본 단위는 Cluster</li>\n<li>도커 컨테이너를 실행할 수 있는 가상의 공간</li>\n<li>EC2와 다른점은 컴퓨팅자원을 기본적으로 갖고있지 않다는 것.</li>\n<li>A라는 기능(프로젝트)을 수행하는 컨테이너들은 A클러스트 내에서만 동작하고, B프로젝트 컨테이너들은 B클러스터 내에서만 동작하는 방식.</li>\n</ul>\n<h4 id=\"클러스터-인스턴스Cluster-Instance\"><a href=\"#클러스터-인스턴스Cluster-Instance\" class=\"headerlink\" title=\"클러스터 인스턴스Cluster Instance\"></a>클러스터 인스턴스<sup>Cluster Instance</sup></h4><ul>\n<li>클러스터에 연결된 EC2인스턴스</li>\n<li>EC2의 ecs-client라는 서비스를 활용해 특정 Cluster로 연결이 가능함.</li>\n<li>ecs-client는 컨테이너 인스턴스의 자원을 모니터링, 관리 등 적절하게 실행하는 역할을 해줌.</li>\n</ul>\n<h3 id=\"태스크Task와-태스크-디피니션Task-definition\"><a href=\"#태스크Task와-태스크-디피니션Task-definition\" class=\"headerlink\" title=\"태스크Task와 태스크 디피니션Task definition\"></a>태스크<sup>Task</sup>와 태스크 디피니션<sup>Task definition</sup></h3><p><a href=\"https://user-images.githubusercontent.com/56995911/108791719-1c5f1d00-75c3-11eb-9b0c-721c0dedccf1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/108791719-1c5f1d00-75c3-11eb-9b0c-721c0dedccf1.png\" alt=\"image\"></a></p>\n<h4 id=\"태스크Task\"><a href=\"#태스크Task\" class=\"headerlink\" title=\"태스크Task\"></a>태스크<sup>Task</sup></h4><ul>\n<li>ECS에서 컨테이너를 실행하는 최소단위.</li>\n<li>컨테이너가 2개이상 모였을때 태스크로 구성가능함.</li>\n<li>같은 태스크 내에 있는 컨테이너들은 모두 같은 컨테이너 인스턴스에서 실행되는것이 보장됨.</li>\n</ul>\n<h4 id=\"태스크-디피니션Task-definition\"><a href=\"#태스크-디피니션Task-definition\" class=\"headerlink\" title=\"태스크 디피니션Task definition\"></a>태스크 디피니션<sup>Task definition</sup></h4><ul>\n<li>컨테이너 네트워크모드, 테스크 Role, 도커이미지, 실행명령어, CPU제한, 메모리 제한 등의 설정을 해주는 태스크관리 역할을 함.</li>\n<li>매번 설정을 해주기 번거로우니 미리 설정의 집합을 하나의 단위로 정의해놓고 사용.</li>\n<li>Task는 클러스터에 종속적이지만, Task Definition(리비전)은 클러스터에 종속되지 않음.<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"family\"</span>: <span class=\"string\">\"webserver\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"containerDefinitions\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"name\"</span>: <span class=\"string\">\"web\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"image\"</span>: <span class=\"string\">\"nginx\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"memory\"</span>: <span class=\"string\">\"100\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"cpu\"</span>: <span class=\"string\">\"99\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"requiresCompatibilities\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"FARGATE\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"networkMode\"</span>: <span class=\"string\">\"awsvpc\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"memory\"</span>: <span class=\"string\">\"512\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"cpu\"</span>: <span class=\"string\">\"256\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n</li>\n</ul>\n<h3 id=\"서비스Service\"><a href=\"#서비스Service\" class=\"headerlink\" title=\"서비스Service\"></a>서비스<sup>Service</sup></h3><p><a href=\"https://user-images.githubusercontent.com/56995911/108792157-fab26580-75c3-11eb-9946-8ca66a93547c.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/56995911/108792157-fab26580-75c3-11eb-9946-8ca66a93547c.png\" alt=\"image\"></a></p>\n<ol>\n<li>Task Definition을 사용하여 1회성으로 실행하는 방법.<br>1) 한번 실행되고 종료되며, 데몬위에서 프로세스로 돌아가는 상황에서 종료 스크립트가 없으면 컨테이너가 남아있을 수 있음.<br>2) 특수한 경우가 아니면 사용되지 않음.</li>\n<li>서비스를 정의하는 방법<br>1) 리플리카 타입</li>\n</ol>\n<ul>\n<li>테스크의 갯수를 지정해주면 자동으로 실행되도록 관리해줌.</li>\n<li>웹서버들에서 사용됨.<br>2) 데몬 타입</li>\n<li>모든 컨테이너 인스턴스에 해당 테스크가 하나씩 실행됨.</li>\n</ul>\n<h3 id=\"엘라스틱-컨테이너-레지스트리Elastic-Conatiner-Registry\"><a href=\"#엘라스틱-컨테이너-레지스트리Elastic-Conatiner-Registry\" class=\"headerlink\" title=\"엘라스틱 컨테이너 레지스트리Elastic Conatiner Registry\"></a>엘라스틱 컨테이너 레지스트리<sup>Elastic Conatiner Registry</sup></h3><ul>\n<li>줄여서 ECR</li>\n<li>도커이미지를 관리해줌.</li>\n<li>콘솔에서 보여줄 수 있으며, 바로 이미지를 불러올 수 있음.</li>\n<li>일반적으로는 Docker hub가 있지만, 무료로는 프라이빗한 이미지는 1개뿐이 저장이 되지 않음.</li>\n</ul>\n<h3 id=\"컨테이너-에이전트Container-Agent\"><a href=\"#컨테이너-에이전트Container-Agent\" class=\"headerlink\" title=\"컨테이너 에이전트Container Agent\"></a>컨테이너 에이전트<sup>Container Agent<sup></h3><ul>\n<li>ECS 클러스터의 각 인프라 Resource에서 실행.</li>\n<li>현재 실행중인 작업과 Resource 사용률에 대한 정보를 ECS로 전송하고 ECS는 Event가 들어올때마다 작업을 시작 or 중지.</li>\n</ul>\n<h3 id=\"AuroraDB가-ECS내에-들어가있지-않은-이유\"><a href=\"#AuroraDB가-ECS내에-들어가있지-않은-이유\" class=\"headerlink\" title=\"AuroraDB가 ECS내에 들어가있지 않은 이유\"></a>AuroraDB가 ECS내에 들어가있지 않은 이유</h3><ul>\n<li>Container는 쉽게 생성하고 쉽게 지울 수 있다.</li>\n<li>이점이 데이터베이스에서는 반대로 적용이 되어야 하기에 컨테이너로 올리지 않았을 것으로 추정</li>\n<li>로드밸런서를 굳이 Instance내에서 갖고있기보다는 오히려 RDS관리가 더 편했을 것으로 보임.</li>\n</ul>\n<h3 id=\"Bastion-Host가-NLB에만-있는-이유\"><a href=\"#Bastion-Host가-NLB에만-있는-이유\" class=\"headerlink\" title=\"Bastion Host가 NLB에만 있는 이유\"></a>Bastion Host가 NLB에만 있는 이유</h3><ul>\n<li>우선, Bastion의 용도는 외부 공격이나 수상한 접근에 방화벽을 세워 막아주는 일종의 게이트웨이 호스트 서버라고 보면 됨.</li>\n<li>ALB단으로 들어오는 요청사항에 대해서는 기본적으로 API-Gateway에서 어느정도 걸러줄 것으로 보고 따로 세우지 않았다고 판단됨.</li>\n<li>HTTPS가 일정부분 보안을 책임져주는 것도 한몫한 것으로 보임.</li>\n</ul>\n<h3 id=\"AZ가용영역을-2개로만-간-이유\"><a href=\"#AZ가용영역을-2개로만-간-이유\" class=\"headerlink\" title=\"AZ가용영역을 2개로만 간 이유?\"></a>AZ가용영역을 2개로만 간 이유?</h3><ul>\n<li>굳이 가용영역을 3개로 무리해서 확장할 필요가 없었을 것으로 보임.</li>\n</ul>\n","text":"ECSElastic Container Service란 ?도커Docker는 응용프로그램들을 소프트웨어 컨테이너안에 배치시키고 이를 신속하게 구축, 테스트, 배포 가능한 소프트웨어 플랫폼컨테이너 가상화에 기반한 서비스엘라스틱 컨테이너 서비스Elastic ","link":"","raw":null,"photos":[],"categories":[{"name":"aws","slug":"aws","count":19,"path":"api/categories/aws.json"}],"tags":[{"name":"AWS","slug":"AWS","count":20,"path":"api/tags/AWS.json"},{"name":"ECS","slug":"ECS","count":3,"path":"api/tags/ECS.json"},{"name":"EC2","slug":"EC2","count":1,"path":"api/tags/EC2.json"}]},{"title":"Armeria(공부중)","slug":"Armeria","date":"2021-02-18T07:04:21.000Z","updated":"2021-02-18T02:52:34.484Z","comments":true,"pin":null,"path":"api/articles/Armeria.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"서문\"><a href=\"#서문\" class=\"headerlink\" title=\"서문\"></a>서문</h2><ul>\n<li>요즘 대세인 아르메리아(Armeria)에 대해 간단히 알아보자.</li>\n<li>오픈소스 기반의 자바 HTTP/2 마이크로서비스 프레임워크</li>\n<li>Netty  개발자와 Line에서 사용중</li>\n<li>공식홈페이지(<a href=\"https://armeria.dev/\" target=\"_blank\" rel=\"noopener\">https://armeria.dev/</a>)</li>\n</ul>\n<h2 id=\"본문\"><a href=\"#본문\" class=\"headerlink\" title=\"본문\"></a>본문</h2><h3 id=\"1-Armeria\"><a href=\"#1-Armeria\" class=\"headerlink\" title=\"1. Armeria?\"></a>1. Armeria?</h3><ul>\n<li>Asynchronous RPC/REST library built on top of Java 8, Netty, HTTP/2, Thrift and gRPC</li>\n<li>고성능 비동기 마이크로서비스를 손쉽게 제작할 수 있음</li>\n<li>단일 어플리케이션에서 단일 포트로 HTTP, gRPC, Thrift를 동시에 지원<br>spring webflux는 서블릿엔진이 아니기 때문에 thrift의 Tservlet을 사용할 수 없음, 별도로 서버구현체를 만들어야해서 포트 소모</li>\n<li>gRPC, Thrift를 브라우저기반에서 테스트 가능</li>\n<li>cf. 사용처 : zipkin, slack, twitter, kakaoPay 등</li>\n</ul>\n<h3 id=\"2-설정방법\"><a href=\"#2-설정방법\" class=\"headerlink\" title=\"2. 설정방법\"></a>2. 설정방법</h3><h4 id=\"Gradle\"><a href=\"#Gradle\" class=\"headerlink\" title=\"Gradle\"></a>Gradle</h4><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    compile <span class=\"string\">\"com.linecorp.armeria:armeria:0.68.2\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"라우팅-전-psvm\"><a href=\"#라우팅-전-psvm\" class=\"headerlink\" title=\"라우팅 전 psvm\"></a>라우팅 전 psvm</h4><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">        ServerBuilder sb = new ServerBuilder();</span><br><span class=\"line\">        sb.http(8080);</span><br><span class=\"line\">  </span><br><span class=\"line\">        sb.service(<span class=\"string\">\"/hello\"</span>, (ctx, res) -&gt;</span><br><span class=\"line\">            HttpResponse.of(</span><br><span class=\"line\">                HttpStatus.OK,</span><br><span class=\"line\">                MediaType.HTML_UTF_8,</span><br><span class=\"line\">                <span class=\"string\">\"&lt;h1&gt;Hello Armeria...!&lt;/h1&gt;\"</span>));</span><br><span class=\"line\">  </span><br><span class=\"line\">        Server server = sb.build();</span><br><span class=\"line\">        CompletableFuture&lt;Void&gt; future = server.start();</span><br><span class=\"line\">        future.join();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"라우팅\"><a href=\"#라우팅\" class=\"headerlink\" title=\"라우팅\"></a>라우팅</h4><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CustomService &#123;</span><br><span class=\"line\">    @Get(<span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">    public HttpResponse <span class=\"function\"><span class=\"title\">defaultMethod</span></span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> HttpResponse.of(</span><br><span class=\"line\">            HttpStatus.OK,</span><br><span class=\"line\">            MediaType.HTML_UTF_8,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;h1&gt;Hello world...!&lt;/h1&gt;\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    @Get(<span class=\"string\">\"/page/:text\"</span>) // nest.js, spring과 큰 차이없음.</span><br><span class=\"line\">    public HttpResponse methodB(@Param(<span class=\"string\">\"text\"</span>) String text) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> HttpResponse.of(</span><br><span class=\"line\">            HttpStatus.OK,</span><br><span class=\"line\">            MediaType.HTML_UTF_8,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;h1&gt;Hello \"</span> + text + <span class=\"string\">\"...!&lt;/h1&gt;\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"라우팅-후-psvm\"><a href=\"#라우팅-후-psvm\" class=\"headerlink\" title=\"라우팅 후 psvm\"></a>라우팅 후 psvm</h4><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">        ServerBuilder sb = new ServerBuilder();</span><br><span class=\"line\">        sb.http(8080);</span><br><span class=\"line\">  </span><br><span class=\"line\">        sb.annotatedService(new CustomService()); //여기서 호출!</span><br><span class=\"line\">  </span><br><span class=\"line\">        Server server = sb.build();</span><br><span class=\"line\">        CompletableFuture&lt;Void&gt; future = server.start();</span><br><span class=\"line\">        future.join();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n\n<h2 id=\"참고자료\"><a href=\"#참고자료\" class=\"headerlink\" title=\"참고자료\"></a>참고자료</h2><h3 id=\"gRPC-란\"><a href=\"#gRPC-란\" class=\"headerlink\" title=\"gRPC 란?\"></a>gRPC 란?</h3><ul>\n<li>RPC는 원격 프로시저 요청(Remote Procedure Call)의 약자로 gRPC는 Google에서 개발.</li>\n<li>통신 프로토콜 : HTTP/2</li>\n<li>표현언어 : 프로토콜 버퍼<br>xml 이나 json은 사람이 읽을 수 있게 직렬화 하지만, 프로토콜 버퍼는 이진바이너리로 직렬화 =&gt; 매우 빨라짐</li>\n<li>특징<br>로드밸런싱, 인증, 양방향 스트리밍 및 흐름 제어, 바인딩 차단 또는 차단 해제 및 취소 및 시간 초과 기능<br>클라이언트에서 서버의 API호출을 메소드처럼 직접 할 수 있음 (MSA에서 강점인 듯?)<br>gRPC 클라이언트는 서버의 메소드의 stub을 작성<br>gRPC 서버는 인터페이스 제공</li>\n</ul>\n<h3 id=\"Thrift-란\"><a href=\"#Thrift-란\" class=\"headerlink\" title=\"Thrift 란?\"></a>Thrift 란?</h3><ul>\n<li>다양한 언어를 지원하는 RPC 프레임워크, facebook 에서 개발</li>\n<li>데이타 타입 및 서비스 인터페이스를 간단한 정의 파일안에 제공하며, 컴파일러는 다른 언어간에 통신할 수 있는 RPC 클라이언트/서버의 코드를 생성</li>\n<li>특징<br>Sync, Async Server API 제공<br>서블릿 제공(org.apache.thrift.server.TServlet)<br>멀티쓰레드 지원 (org.apache.thrift.server.ThreadPoolServer : worker thread 지정)</li>\n</ul>\n","text":"서문요즘 대세인 아르메리아(Armeria)에 대해 간단히 알아보자.오픈소스 기반의 자바 HTTP/2 마이크로서비스 프레임워크Netty  개발자와 Line에서 사용중공식홈페이지(https://armeria.dev/)본문1. Armeria?Asynchro","link":"","raw":null,"photos":[],"categories":[{"name":"aws","slug":"aws","count":19,"path":"api/categories/aws.json"}],"tags":[{"name":"AWS","slug":"AWS","count":20,"path":"api/tags/AWS.json"},{"name":"Cloud9","slug":"Cloud9","count":2,"path":"api/tags/Cloud9.json"},{"name":"Web","slug":"Web","count":2,"path":"api/tags/Web.json"},{"name":"Debugger","slug":"Debugger","count":2,"path":"api/tags/Debugger.json"},{"name":"python","slug":"python","count":4,"path":"api/tags/python.json"}]},{"title":"Jenkins vs Bamboo","slug":"Jenkins-Bamboo-CI-CD","date":"2021-02-09T05:53:44.000Z","updated":"2021-02-09T07:40:41.161Z","comments":true,"pin":null,"path":"api/articles/Jenkins-Bamboo-CI-CD.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"서문\"><a href=\"#서문\" class=\"headerlink\" title=\"서문\"></a>서문</h2><ul>\n<li>Jenkins와 Bamboo라고 많이들 들어보았을 것이다. 빌드테스트 자동화와 배포자동화에 특화된 솔루션이며, Hudson사가 원조임.</li>\n<li>Hudson 은 오라클 인수후 지속적으로 사용자가 줄고 있는 듯 하고 위 두개 외에 솔루션들은 따로 조사하지 않았으므로 포스팅 하지 않음.</li>\n</ul>\n<h2 id=\"본문\"><a href=\"#본문\" class=\"headerlink\" title=\"본문\"></a>본문</h2><ul>\n<li>두 개의 솔루션에 대해 먼저 장점과 단점을 알고 가는 것이 좋을 것 같다.</li>\n</ul>\n<h3 id=\"1-Jenkins\"><a href=\"#1-Jenkins\" class=\"headerlink\" title=\"1. Jenkins\"></a>1. Jenkins</h3><h4 id=\"장점\"><a href=\"#장점\" class=\"headerlink\" title=\"장점\"></a>장점</h4><ol>\n<li>무료이고 Reference 및 사용자가 많고 정보가 많은 편이다. (openstack 의 CI 에도 적용되어 있다.- <a href=\"https://jenkins.openstack.org/\" target=\"_blank\" rel=\"noopener\">https://jenkins.openstack.org/</a>)</li>\n<li>Hudson core 개발자가 jenkins 를 시작했고 주요 플러그인 개발자도 jenkins 로 전환해서 개발 속도가 빠르고 플러그인 지원이 좋은 편이다.</li>\n<li>설치 및 사용이 간단하다. 실제로 maven 으로 build 가 구성되어 있다면 jenkins 설치후 project 만드는데 얼마 안 걸린다.</li>\n<li>Remote Access API 를 제공하므로 다른 솔루션에서 연계하여 기능 확장이 가능하다.</li>\n</ol>\n<h4 id=\"단점\"><a href=\"#단점\" class=\"headerlink\" title=\"단점\"></a>단점</h4><ol>\n<li>프로젝트 별 보안 및 권한 설정등이 불편하다. (bamboo 에 비해)</li>\n<li>JIRA나 redmine 등 Issue tracking 과 연계가 불편하거나 완벽하지 않다.</li>\n</ol>\n<h3 id=\"2-Jenkins\"><a href=\"#2-Jenkins\" class=\"headerlink\" title=\"2. Jenkins\"></a>2. Jenkins</h3><h4 id=\"장점-1\"><a href=\"#장점-1\" class=\"headerlink\" title=\"장점\"></a>장점</h4><ol>\n<li>손쉽고 직관적인 UI를 갖고 있고 상용 SW 에 걸맞게 예쁜 외양을 자랑한다.</li>\n<li>atlassian 제품군과 완벽한 통합 제공. JIRA 의 대쉬보드나 confluence의 Page에 bamboo build chart 를 붙일수도 있고 JIRA 의 특정 이슈와 관련된 build 내역을 조회하는 등 atlassian 제품을 기존에 사용하고 있다면 각 제품군을 통합해서 더욱 유기적으로 사용할 수 있다.</li>\n<li>MS의 Visual Studio, Mac OSX 의 XCode 등 Java 이외의 개발 환경을 지원한다. ( Visual Studio 지원은 아직 그리 잘 돌아가지 않고 복잡해서 시행착오를 좀 거쳐야 하고 써본 경험상 bamboo 에 붙이는건 그리 추천하지 않는다.)</li>\n<li>Jenkins 에 비해 프로젝트 권한 설정이나 분산 빌드가 아주 간편하다.</li>\n<li>Remote Access API 를 제공하므로 다른 솔루션에서 연계하여 기능 확장이 가능하다.</li>\n</ol>\n<h4 id=\"단점-1\"><a href=\"#단점-1\" class=\"headerlink\" title=\"단점\"></a>단점</h4><ol>\n<li>제법 비싼 비용이 발생한다.  (build 를 할수 있는 remote agent 수 따라 라이센스 비용이 책정되는데 5 remote agent 가 $2,200 이다. 1년후마다 매년 구입가의 50% subscription 비용 추가 발생.)</li>\n<li>Project, Plan, Stage, Task 의 개념이 복잡해서 익숙해지고 제대로 쓰려면 약간의 시간이 필요하다.</li>\n</ol>\n<h2 id=\"결론\"><a href=\"#결론\" class=\"headerlink\" title=\"결론\"></a>결론</h2><ul>\n<li>기존 atlassian 제품을 쓰고 있기에, Bamboo로 도입하기로 결정했다.</li>\n<li>Jenkins로 프로젝트를 구성하고 Bamboo로 Migration이 가능하기에 더 기능이 많은 Bamboo가 좋은 선택으로 보여진다.</li>\n<li>나는 짬이 안되므로 Bamboo 관리자 계정을 빌려 학습하였다.</li>\n</ul>\n","text":"서문Jenkins와 Bamboo라고 많이들 들어보았을 것이다. 빌드테스트 자동화와 배포자동화에 특화된 솔루션이며, Hudson사가 원조임.Hudson 은 오라클 인수후 지속적으로 사용자가 줄고 있는 듯 하고 위 두개 외에 솔루션들은 따로 조사하지 않았","link":"","raw":null,"photos":[],"categories":[{"name":"CICD","slug":"CICD","count":1,"path":"api/categories/CICD.json"}],"tags":[{"name":"CI","slug":"CI","count":1,"path":"api/tags/CI.json"},{"name":"CD","slug":"CD","count":1,"path":"api/tags/CD.json"},{"name":"Bamboo","slug":"Bamboo","count":1,"path":"api/tags/Bamboo.json"},{"name":"Jenkins","slug":"Jenkins","count":1,"path":"api/tags/Jenkins.json"}]}]}