{"title":"OAuth 2.0 마스터 (Mastering OAuth 2.0)","slug":"OAuth2-0","date":"2020-06-29T03:46:47.000Z","updated":"2020-06-29T03:47:52.417Z","comments":true,"path":"api/articles/OAuth2-0.json","photos":[],"link":"","excerpt":"","covers":null,"content":"<p>OAuth 2.0은 서로 다른 두 집단이 정보와 리소스를 안전하고 신뢰할 수 있는 방법으로 공유할 수 있게 해주는 프로토콜이다.</p>\n<p>※ OAuth 2.0은 OAuth 1.0과 호환되지 않는다.</p>\n<ul>\n<li>인증과 인가</li>\n</ul>\n<ul>\n<li>인증(authentication) : 누군가(또는 시스템)가 그들이 말하는 그 사람이 맞는지 실제로 확인하는 절차</li>\n<li>인가(authorization) : 일단 인증이 됐다면 당신이 하고자 하는 어떤 일을 할 수 있는 권한이 있는지 판단하는 절차</li>\n</ul>\n<p>결국에는 보호된 리소스에 해당 리소스 소유자 대신해서 접근하는 것</p>\n<ul>\n<li>연합된 신원(federated identity) : 어떤 서비스가 다른 서비스의 계정을 이용한 인증을 허용하는 것</li>\n<li>권한 위임(delegated authority) : 어떤 서비스나 어플리케이션이 사용자의 리소스에 대신 접근할 수 있는 것</li>\n</ul>\n<p>OAuth 2.0 동작<br>사용자 동의(user consent)</p>\n<ul>\n<li>그랜트(grant) 유형</li>\n</ul>\n<ul>\n<li>인가 코드 그랜트(authorization code grant) : 서버 사이드 워크플로우</li>\n<li>암시적 그랜트(implicit grant) : 클라이언트 사이드 워크플로우<br>위 2가지를 가장 많이 사용되고 OAuth 2.0 스펙에는 추가적인 2가지 유형의 그랜트가 있다.</li>\n<li>리소스 소유자 비밀번호 자격증명 그랜트(resource owner password credentials grant)</li>\n<li>클라이언트 자격증명 그랜트(client credentials grant)</li>\n</ul>\n<p>OAuth 2.0 클라이언트에는 2가지 신뢰 레벨의 클라이언트만 있다.</p>\n<ul>\n<li>신뢰 클라이언트 (trusted client)</li>\n<li>비신뢰 클라이언트 (untrusted client)<br>신뢰 레벨을 판단하는 요소 : 안전하게 정보를 저장하고 전송하는 능력</li>\n</ul>\n<ol>\n<li>신뢰 클라이언트</li>\n</ol>\n<p>-&gt; 클라이언트 자격증명과 토큰 또는 어플리케이션이 필요로 하는 다른 리소스를 안전하게 저장할 수 있음<br>-&gt; ex) 기밀 정보를 안전하게 저장하고 전송할 수 있는 백엔드 서버가 존재하는 전형적인 3계층 클라이언트-서버-데이터베이스 어플리케이션</p>\n<ol start=\"2\">\n<li>비신뢰 클라이언트</li>\n</ol>\n<p>-&gt; 기밀 정보를 안전하게 저장하거나 전송할 수 없음<br>-&gt; 정보를 안전하게 저장해주는 서버가 없음<br>-&gt; ex) 브라우저 기반의 어플리케이션</p>\n<p>※ OAuth 2.0 스펙에서 trusted(신뢰) = confidential, untrusted(비신뢰) = public</p>\n<ul>\n<li>클라이언트 사이드 워크플로우<br>비신뢰 클라이언트에 가장 적합한 것이 암시적 그랜트이다.<br>ex) GoodApp이 암시적 그랜트를 이용해 페이스북의 친구 목록에 대한 접근 요청</li>\n</ul>\n<p>-&gt; GoodApp은 비신뢰 클라이언트이므로 신분 증명이나 토큰을 저장할 수 없다.</p>\n<ol>\n<li>GoodApp은 사용자를 페이스북에 연결한다. 페이스북은 사용자에게 GoodApp이 사용자의 친구 목록에 접근하는 것을 허용하는지 물어본다.</li>\n<li>(사용자가 허락한다.) 페이스북은 GoodApp에게 사용자의 페이스북 친구 목록에 접근하는데 사용할 수 있는 키를 전달한다.</li>\n<li>GoodApp은 페이스북으로부터 전달받은 키를 이용해 페이스북에게 사용자의 친구 목록을 요청한다.</li>\n<li>페이스북은 전달된 키를 확인한 후 GoodApp에게 사용자의 친구 목록을 전달한다.</li>\n<li>GoodApp은 전달받은 친구 목록으로 자기 서비스를 제공한다.</li>\n</ol>\n<p>엑세스토큰과 bearer 토큰<br>-&gt; 엑세스토큰은 보호된 리소스에 접근할 수 있는 권한을 나타내는 문자열 값<br>-&gt; bearer 토큰은 엑세스토큰의 한 유형<br>-&gt; 가장 많이 사용되는 토큰 유형<br>-&gt; bearer 토큰은 토큰만 가지고 있으면 더 이상 필요한 것이 없다는 의미에서 이름이 붙여짐, 즉 특정 리소스에 접근하기 위해 토큰 외에 다른 것은 필요 없음</p>\n<p>언제 암시적 그랜트를 사용해야 하는가?<br>-&gt; 비신뢰 클라이언트를 위해<br>-&gt; 사용자의 데이터를 오랜 기간 저장할 필요가 없는 클라이언트 (ex. 웹 브라우저 기반 어플리케이션)</p>\n<p>비신뢰 클라이언트의 장단점<br>장점) 간편함, 구현이 단순함<br>단점) 보안성이 낮음<br>      단기간 접근만 가능 : 비신뢰 클라이언트이므로 오랜 기간 키를 저장할 수 없기 때문에 사용자는 신뢰 클라이언트보다 더 자주 인증을 다시 받고 토큰을 재발급해야 한다.</p>\n<h3 id=\"개발가이드\"><a href=\"#개발가이드\" class=\"headerlink\" title=\"개발가이드\"></a>개발가이드</h3><p>-&gt; 암시적 그랜트 유형을 이용하는 비신뢰 클라이언트를 개발한다면 읽기 전용 모드의 요청만 할 수 있도록 제한하는 것이 좋다.</p>\n<ul>\n<li>서버 사이드 워크플로우<br>신뢰 클라이언트는 클라이언트 자격증명과 같은 기밀 정보를 안전하게 저장할 수 있어야 한다.</li>\n</ul>\n<p>-&gt; 이번 GoodApp은 신뢰 클라이언트</p>\n<ol>\n<li>GoodApp은 사용자를 페이스북에 연결한다. 페이스북은 사용자에게 GoodApp이 사용자의 친구 목록에 접근하는 것을 허용하는지 물어본다.</li>\n<li>(사용자가 허락한다.) 페이스북은 GoodApp에게 사용자의 페이스북 친구 목록에 접근하는데 사용할 수 있는 키와 교환할 수 있는 태그(tag)를 준다.</li>\n<li>GoodApp은 페이스북으로부터 전달받은 태그를 이용해 사용자의 페이스북 친구 목록을 요청할 수 있는 키를 요청한다.</li>\n<li>페이스북은 절달된 태그를 확인한 후 GoodApp 서버에게 키를 전달한다.</li>\n<li>GoodApp은 페이스북으로부터 전달받은 키를 이용해 페이스북에게 사용자의 친구 목록을 요청한다.</li>\n<li>페이스북은 전달된 키를 확인한 후 GoodApp에게 사용자의 친구 목록을 전달한다.</li>\n<li>GoodApp은 전달받은 친구 목록으로 자기 서비스를 제공한다.</li>\n</ol>\n<p>[중요] 키를 얻기 위해 사용하는 태그는 한 번만 사용할 수 있다.</p>\n<p>※ OAuth 2.0 스펙에서 인가 코드(authorization code)가 태그에 해당한다.</p>\n<p>[포인트] 비신뢰 클라이언트와 중요한 차이점은 엑세스 토큰이 브라우저에게 절대 전달되지 않는다는 것, 페이스북과 GoodApp 서버 간에 엑세스 토큰이 직접 교환됨 -&gt; 엑세스 토큰 유출 위험도가 낮아짐</p>\n<p>신뢰 클라이언트의 장단점<br>장점) 더 안전<br>      장시간, 오프라인 접근 가능 : 키를 저장할 수 있으므로<br>단점) 더 복잡</p>\n<h3 id=\"개발가이드-1\"><a href=\"#개발가이드-1\" class=\"headerlink\" title=\"개발가이드\"></a>개발가이드</h3><p>많은 개발자들이 SSL이나 TLS와 같은 안전한 전송 프로토콜과 함께 사용하면 정보를 안전하게 저장하고 전송해야 한다는 요구 사항을 만족한다고 생각한다.<br>따라서 그들이 만든 어플리케이션이 신뢰 클라이언트라고 생각하나 문제가 있다…</p>\n<p>OAuth 2.0 클라이언트가 되기 위한 4개의 단계</p>\n<ol>\n<li>클라이언트 어플리케이션 등록</li>\n<li>엑세스 토큰 얻기</li>\n<li>엑세스 토큰을 이용해서 보호된 리소스에 접근</li>\n<li>엑세스 토큰 갱신</li>\n</ol>\n<p>※ 엑세스 토큰 갱신<br>엑세스 토큰 갱신은 신뢰 클라이언트만 가능하다. 클라이언트 어플리케이션이 엑세스 토큰을 갱신하려면 리프레쉬 토큰(refresh token)을 안전하게 저장할 수 있어야 하기 때문에</p>\n<p>1단계 : 클라이언트 어플리케이션 등록<br>어플리케이션 등록 후 사용하게될 정보 셋</p>\n<ul>\n<li>클라이언트 ID(client id) : 클라이언트 어플리케이션의 고유한 ID, 반드시 유일해야함</li>\n<li>클라이언트 시크릿(client secret) : 어플리케이션을 위한 비밀 키, 어플리케이션의 신원</li>\n<li>리다이렉션 엔드포인트(redirection endpoint) : 서비스 제공자가 응답(토큰 또는 에러)을 전달하기 위해 사용하는 엔드포인트, 데스크탑이나 모바일 네이티브 어플리케이션의 경우는 서비스 제공자에 의해 제공 여부가 결정됨</li>\n<li>인가 엔드포인트(authorization endpoint) : 클라이언트 어플리케이션이 인가 플로우를 시작할 때 사용하는 엔드포인트, 서비스 제공자에 의해 제공 여부가 결정</li>\n<li>토큰 엔드포인트(token endpoint) : 클라이언트 어플리케이션이 토큰 플로우를 시작할 때 사용하는 엔드포인트, 서비스 제공자에 의해 제공 여부가 결정</li>\n</ul>\n<p>ex) GoodApp 어플리케이션의 예</p>\n<ul>\n<li>클라이언트 ID(client id) : goodapp-541106</li>\n<li>클라이언트 시크릿(client secret) : 38D83HHHFF873RASDPPEKJ1KHJZL</li>\n<li>리다이렉션 엔드포인트(redirection endpoint) : <a href=\"https://www.goodapp.com/callback\" target=\"_blank\" rel=\"noopener\">https://www.goodapp.com/callback</a></li>\n<li>인가 엔드포인트(authorization endpoint) : <a href=\"https://api.facebook.com/auth\" target=\"_blank\" rel=\"noopener\">https://api.facebook.com/auth</a></li>\n<li>토큰 엔드포인트(token endpoint) : <a href=\"https://api.facebook.com/token\" target=\"_blank\" rel=\"noopener\">https://api.facebook.com/token</a></li>\n</ul>\n<p>[포인트] 비신뢰 클라이언트에게는 클라이언트 시크릿이 제공되지 않을 것, 안전하게 저장할 수 없기 때문에</p>\n<p>*** 엑세스 토큰<br>범위(scope)</p>\n<p>그런 문자열은 서비스 제공자가 정의하는 것이다.</p>\n<p>접근 기간(duration of access)</p>\n<p>영구 토큰(perpetual token)도 있으나 극히 드물다.</p>\n<p>-&gt; 대부분의 서비스 제공자는 대략 몇 분이나 몇 시간 정도의 접근 기간을 가지는 토큰을 발급한다.<br>-&gt; 접근 기간은 요청되는 범위 뿐만 아니라 서비스 제공자에 따라 달라지며, 일반적으로 30분에서 몇 시간 정도로 정해짐<br>-&gt; 또한 읽기/쓰기가 가능한 접근 권한보다 읽기만 가능한 접근 권한이 좀 더 긴 접근 기간을 갖는 경향이 있음</p>\n<p>토큰 폐기(token revocation) : 서비스 제공자가 지원할 수도 있고 지원하지 않을 수도 있고… 그러나 보안상 중요함</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~~~</span><br></pre></td></tr></table></figure></div>\n\n\n\n\n<p>리다이렉션 엔드포인트를 어플리케이션을 등록할 때 설정한다.</p>\n<p>인가 엔드포인트와 토큰 엔드포인트는 서비스 제공자가 결정하는 것</p>\n<p>@@@ 암시적 그랜트 플로우 @@@</p>\n<p>1) 인가 요청</p>\n<p>인가 요청을 보내는 곳 : 서비스 제공자의 인가 엔드포인트<br>필요한 파라미터도 함께 전달하고 전달되는 파라미터는 application/x-www-form-urlencoded 포멧으로 인코딩돼야 한다.</p>\n<p>ex) 일반적인 형태의 인가 요청<br>GET /authorize?<br>response_type=token&amp;<br>client_id=[CLIENT_ID]&amp;<br>redirect_uri=[REDIRECT_URI]&amp;<br>scope=[SCOPE]&amp;<br>state=[STATE] http/1.1<br>Host: server.example.com</p>\n<ul>\n<li>response_type : (필수) 암시적 그랜트 플로우를 사용하고 있음을 나타내기 위해 값을 token으로 세팅해야 한다.</li>\n<li>client_id : (필수) 어플리케이션의 고유한 클라이언트 ID</li>\n<li>redirect_uri : (선택) 서비스 제공자가 요청에 대한 응답을 전달하기 위해 사용하게 될 리다이렉션 엔트포인트. 서비스 제공자는 요청이 성공하면 엑세스 토큰을, 실패하면 에러 메시지를 전달한다.</li>\n<li>scpoe : (선택) 클라이언트가 요청하는 접근 권한의 범위를 나타냄</li>\n<li>state : (권장) 사용하는 것이 좋다. 클라이언트가 서비스 제공자에게 전달하면 서비스 제공자는 이 값을 다시 응답에 포함해서 전달한다. CSRF(Cross-Site Request Forgery) 공격을 차단하기 위한 목적으로 사용될 수 있다.</li>\n</ul>\n<p>ex) 인가 응답(성공)<br>HTTP/1.1 302 Found<br>Location: [REDIRECT_URI]#<br>access_token=[ACCESS_TOKEN]&amp;<br>token_type=[TOKEN_TYPE]&amp;<br>expires_in=[EXPIRES_IN]&amp;<br>scope=[SCOPE]&amp;<br>state=[STATE]</p>\n<ul>\n<li>access_token : (필수) 얻고자 한 토큰, 이 토큰을 이용해서 사용자의 프로파일과 글에 접근할 수 있다.</li>\n<li>token_type : (필수) 전달된 토큰의 유형. 이는 거의 bearer 토큰 유형일 것</li>\n<li>expires_in : (선택) 토큰의 유효 기간(초 단위), 이 값은 선택 사항으로 서비스 제공자는 이 값을 전달하지 않을 수도 있다.</li>\n<li>scope : (조건부로 필수) 인가된 접근 범위가 요청된 범위와 일치한다면 이 값은 아마 생략될 것이다. 하지만 요청된 범위와 인가된 범위가 다르다면 이 파라미터를 통해 인가된 범위가 전달</li>\n<li><ul>\n<li>[중요] : OAuth 2.0 스펙에서는 공백으로 구분한다. 비록 많은 서비스 제공자가 콤마도 지원하겠지만…</li>\n</ul>\n</li>\n<li>state : (조건부로 필수) 인가 요청에 state 파라미터가 포함됐다면 응답에도 이 파라미터가 존재해야 한다.</li>\n</ul>\n<p>ex) 인가 응답(실패)<br>HTTP/1.1 302 Found<br>Location: [REDIRECT_URI]#<br>error=[ERROR_CODE]&amp;<br>error_description=[ERROR_DESCRIPTION]&amp;<br>error_uri=[ERROR_URI]&amp;<br>state=[STATE]</p>\n<ul>\n<li>error : (필수) 에러 코드로 인가 요청에 실패한 이유를 나타냄</li>\n<li>-에러 코드 종류</li>\n<li>– invalid_request : 요청 데이터가 잘못돼서 처리할 수 없음</li>\n<li>– unauthorized_client : 클라이언트 어플리케이션이 요청을 전달할 권한이 없음</li>\n<li>– access_denied : 사용자가 인가 요청을 거부함</li>\n<li>– unsupported_response_type : 잘못된 응답 유형이 사용됐음. 앞에서 암시적 그랜트 유형을 사용했기 때문에 응답 유형으로 token을 사용해야 한다.</li>\n<li>– invalid_scope : 잘못된 범위가 사용됐음</li>\n<li>– server_error : 서버 내에서 에러가 발생해 인가 요청을 제대로 처리할 수 없음</li>\n<li>– temporarily_unavailable : 인가 서버가 일시적인 장애 상태임</li>\n<li>error_description : (선택) 사람이 읽을 수 있는 형태의 에러 메시지</li>\n<li>error_uri : (선택) 에러에 대해 좀 더 자세한 정보를 담고 있는 웹 문서에 대한 링크</li>\n<li>state : (조건부 필수) 인가 요청에 state 파라미터가 포함됐다면 응답에도 이 파라미터가 존재해야 한다.</li>\n</ul>\n<p>[중요] 클라이언트가 인가 요청을 보내는 엔드포인트는 서비스 제공자의 서버에 위치해야 한다는 것</p>\n<p>@@@ 서버 사이드 플로우 (인가 코드 그랜트 플로우) @@@<br>-&gt; 클라이언트 사이드 플로우(암시적 그랜트 플로우)보다는 좀 더 복잡하지만 더욱 안전함<br>-&gt; 일반적으로 백엔드와 함께 동작하는 웹 어플리케이션에서 사용됨<br>-&gt; 인가 코드를 전달할 때 프론트엔드가 아닌 백엔드 즉 서버에 전달한다.<br>[중요] 서버 사이드에서 인가 코드를 교환하는 것이 차이점으로 클라이언트 자격증명과 토큰을 안전하게 관리하고 전송할 수 있어야 한다.<br>비신뢰 클라이언트는 그런 자격증명을 안전하게 저장할 수 없기 때문에(브라우저는 안전하다고 여겨지지 않는다.) 인가 코드 그랜트 플로우를 사용할 수 없다.</p>\n<p>@ 인가 요청<br>-&gt; 암시적 그랜트 플로우와 유일한 차이점은 response_type 파라미터의 값이 token이 아닌 code로 세팅돼야 함<br>ex) 일반적인 형태의 인가 요청<br>GET /authorize?<br>response_type=code&amp;<br>client_id=[CLIENT_ID]&amp;<br>redirect_uri=[REDIRECT_URI]&amp;<br>scope=[SCOPE]&amp;<br>state=[STATE] http/1.1<br>Host: server.example.com</p>\n<ul>\n<li>response_type : (필수) 인가 코드 그랜트 플로우를 사용한다는 것을 나타내기 위해 값을 code로 세팅해야 한다.</li>\n<li>client_id : (필수) 어플리케이션의 고유한 클라이언트 ID</li>\n<li>redirect_uri : (선택) 서비스 제공자가 요청에 대한 응답을 전달하기 위해 사용하게 될 리다이렉션 엔트포인트. 서비스 제공자는 요청이 성공하면 엑세스 토큰을, 실패하면 에러 메시지를 전달한다.</li>\n<li>scpoe : (선택) 클라이언트가 요청하는 접근 권한의 범위를 나타냄</li>\n<li>state : (권장) 사용하는 것이 좋다. 클라이언트가 서비스 제공자에게 전달하면 서비스 제공자는 이 값을 다시 응답에 포함해서 전달한다. CSRF(Cross-Site Request Forgery) 공격을 차단하기 위한 목적으로 사용될 수 있다.</li>\n</ul>\n<p>ex) 샘플 어플리케이션의 경우</p>\n<ul>\n<li>response_type : code</li>\n<li>client_id : wmiig-550106</li>\n<li>redirect_uri : <a href=\"http://wmiig.com/callback\" target=\"_blank\" rel=\"noopener\">http://wmiig.com/callback</a></li>\n<li>scope : public_profile, user_posts</li>\n</ul>\n<p>@ 인가 응답 (성공)<br>ex)<br>HTTP/1.1 302 Found<br>Location: [REDIRECT_URI]?<br>code=[AUTHORIZATION_CODE]&amp;<br>scope=[SCOPE]</p>\n<p>[중요] 응답 값이 URL 프래그먼트가 아닌 URL 질의 컴포넌트로 전달</p>\n<ul>\n<li>code : (필수) 엑세스 토큰과 교환하는 데 사용하는 인가 코드</li>\n<li>state : (조건부로 필수) : 인가 요청에 state 파라미터가 포함됐다면 응답에도 이 파라미터가 존재해야 한다.</li>\n</ul>\n<p>[중요] 인가 코드는 한 번만 사용할 수 있고 짧은 만료 시간을 가진다.(OAuth 2.0 스펙은 10분으로 제한 권장) 따라서 클라이언트는 인가 코드를 받으면 그것을 곧바로 사용해야 한다.</p>\n<p>@ 인가 응답 (에러)<br>ex) 응답 값이 URL 프래그먼트가 아닌 URL 질의 컴포넌트로 전달<br>HTTP/1.1 302 Found<br>Location: [REDIRECT_URI]#<br>error=[ERROR_CODE]&amp;<br>error_description=[ERROR_DESCRIPTION]&amp;<br>error_uri=[ERROR_URI]&amp;<br>state=[STATE]</p>\n<ul>\n<li>error : (필수) 에러 코드로 인가 요청에 실패한 이유를 나타냄</li>\n<li>-에러 코드 종류</li>\n<li>– invalid_request : 요청 데이터가 잘못돼서 처리할 수 없음</li>\n<li>– unauthorized_client : 클라이언트 어플리케이션이 요청을 전달할 권한이 없음</li>\n<li>– access_denied : 사용자가 인가 요청을 거부함</li>\n<li>– unsupported_response_type : 잘못된 응답 유형이 사용됐음. 앞에서 암시적 그랜트 유형을 사용했기 때문에 응답 유형으로 token을 사용해야 한다.</li>\n<li>– invalid_scope : 잘못된 범위가 사용됐음</li>\n<li>– server_error : 서버 내에서 에러가 발생해 인가 요청을 제대로 처리할 수 없음</li>\n<li>– temporarily_unavailable : 인가 서버가 일시적인 장애 상태임</li>\n<li>error_description : (선택) 사람이 읽을 수 있는 형태의 에러 메시지</li>\n<li>error_uri : (선택) 에러에 대해 좀 더 자세한 정보를 담고 있는 웹 문서에 대한 링크</li>\n<li>state : (조건부 필수) 인가 요청에 state 파라미터가 포함됐다면 응답에도 이 파라미터가 존재해야 한다.</li>\n</ul>\n<p>@ 액세스 토큰 요청<br>-&gt; 서비스 제공자의 토큰 엔드포인트로 필요한 파라미터와 함께 POST 요청을 보내야 한다.<br>-&gt; application/x-www-form-urlencoded 포멧으로 전달해야 함<br>ex)<br>POST /token HTTP/1.1<br>Host: server.example.com<br>Authorization: Basic [ENCODED_CLIENT_CREDENTIALS]<br>Content-Type: application/x-www-form-urlencoded</p>\n<p>grant_type=authorization_code&amp;<br>code=[AUTHORIZATION_CODE]&amp;<br>redirect_uri=[REDIRECT_URI]&amp;<br>client_id=[CLIENT_ID]</p>\n<ul>\n<li>grant_type : (필수) 액세스 토큰으로 교환하고자 한다는 것을 나타내기 위해 authorization_code로 세팅해야 한다.</li>\n<li>code : (필수) 인가 요청에 의해 전달받은 인가 코드 값</li>\n<li>redirect_uri : (조건부로 필수) 인가 요청에 리다이렉션 엔드포인트가 포함된다면 액세스 토큰 요청에도 리다이렉션 엔드포인트가 포함돼야 한다.</li>\n<li>client_id : (필수) 어플리케이션의 고유한 클라이언트 ID</li>\n</ul>\n<p>엑세스 토큰을 요청하려면 위 파라미터 전달 뿐만 아니라 클라이언트 어플리케이션은 서비스 제공자에게 자기 자신을 증명해야 한다.<br>OAuth 2.0 스펙에는 클라이언트 인증을 위해 어떤 특정한 인증 메커니즘을 사용해야 한다고 말하지 않지만 일반적으로 HTTP 기본 인증(HTTP basic authentication)을 사용한다.<br>이는 위의 Authorization 헤더로 구현된다.<br>즉 HTTP 헤더의 Authorization 부분에는 인증 유형을 나타내는 ‘Basic’과 HTTP 기본 인증 스펙에서 정의한 인코딩 방식인 Base64로 인코딩된 클라이언트 자경증명이 포함된다.<br>[CLIENT_ID] : [CLIENT_SECRET]</p>\n<p>HTTP 기본 인증 프로토콜 = 기본 인증</p>\n<p>이를 사용하지 않는 예전 방식의 요청<br>ex)<br>POST /token HTTP/1.1<br>Host: server.example.com<br>Content-Type: application/x-www-form-urlencoded</p>\n<p>grant_type=authorization_code&amp;<br>code=[AUTHORIZATION_CODE]&amp;<br>redirect_uri=[REDIRECT_URI]&amp;<br>client_id=[CLIENT_ID]&amp;<br>client_secret=[CLIENT_SECRET]</p>\n<p>@엑세스 토큰 응답</p>\n<ul>\n<li>성공인 경우<br>ex)<br>HTTP/1.1 200 OK<br>Content-Type: application/json;charset=UTF-8<br>Cache-Control: no-store<br>Pragma: no-cache<br>{<br>  “access_token”:”???”,<br>  “token_type”:”bearer”,<br>  “expires_in”:3600,<br>  “refresh_token”:”???”,<br>}</li>\n</ul>\n<p>보통 JSON 포멧으로 전달됌, XML이나 Key-Value 포멧일 수도 있다.</p>\n<ul>\n<li>실패인 경우</li>\n<li><blockquote>\n<p>HTTP 400(Bad Request) 에러 코드를 반환할 것이다.<br>ex) HTTP/1.1 400 Bad Request<br>Content-Type: application/json;charset=UTF-8<br>Cache-Control: no-store<br>Pragma: no-cache<br>{<br>   “error”:”invalid_client”<br>}</p>\n</blockquote>\n</li>\n</ul>\n","categories":[{"name":"tip","slug":"tip","count":20,"path":"api/categories/tip.json"}],"tags":[{"name":"Security","slug":"Security","count":1,"path":"api/tags/Security.json"},{"name":"OAuth","slug":"OAuth","count":1,"path":"api/tags/OAuth.json"},{"name":"Master","slug":"Master","count":1,"path":"api/tags/Master.json"}]}