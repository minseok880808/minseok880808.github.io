{"title":"Kinesis WebRTC","slug":"Kinesis-WebRTC","date":"2021-03-11T07:10:56.000Z","updated":"2021-03-11T07:58:37.628Z","comments":true,"path":"api/articles/Kinesis-WebRTC.json","photos":[],"link":"","excerpt":"","covers":["https://user-images.githubusercontent.com/62123161/110749545-99a5b580-8284-11eb-8fad-54274432de3a.png","https://user-images.githubusercontent.com/62123161/110749938-189aee00-8285-11eb-9227-93f4fc395e61.png","https://user-images.githubusercontent.com/62123161/110750295-9ced7100-8285-11eb-82a8-affa6f8e55d4.png","https://user-images.githubusercontent.com/62123161/110750602-138a6e80-8286-11eb-8e75-6078530b7e56.png"],"content":"<h2 id=\"WebRTC-가격비교\"><a href=\"#WebRTC-가격비교\" class=\"headerlink\" title=\"WebRTC 가격비교\"></a>WebRTC 가격비교</h2><p>WebRTC 기능을 사용하면 해당 월의 활성 상태인 신호 채널 수, 송수신된 신호 메시지 수 및 미디어 중계에 사용된 TURN 스트리밍 분에 따라 부과됩니다.</p>\n<p>해당 월 기간에 언제든지 디바이스 또는 애플리케이션이 신호 채널에 연결되면 신호 채널은 활성으로 간주됩니다. TURN 스트리밍 분은 1분 간격으로 계량됩니다.</p>\n<p><a href=\"https://user-images.githubusercontent.com/62123161/110749545-99a5b580-8284-11eb-8fad-54274432de3a.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/110749545-99a5b580-8284-11eb-8fad-54274432de3a.png\" alt=\"image\"></a></p>\n<h2 id=\"WebRTC-검토\"><a href=\"#WebRTC-검토\" class=\"headerlink\" title=\"WebRTC 검토\"></a>WebRTC 검토</h2><h3 id=\"OverView\"><a href=\"#OverView\" class=\"headerlink\" title=\"OverView\"></a>OverView</h3><ul>\n<li>Official Site : <a href=\"https://webrtc.org\" target=\"_blank\" rel=\"noopener\">https://webrtc.org</a></li>\n<li>W3C Specification : <a href=\"https://w3c.github.io/webrtc-pc/\" target=\"_blank\" rel=\"noopener\">https://w3c.github.io/webrtc-pc/</a> (latest published version : WebRTC 1.0: Real-Time Communication Between Browsers (w3.org))</li>\n<li>Associated Test Suite (Browser base)</li>\n<li>wpt/webrtc at master · web-platform-tests/wpt · GitHub</li>\n<li>Web 기반, Peer to Peer 실시간 비디오/오디오 통신 Specification</li>\n</ul>\n<p><a href=\"https://user-images.githubusercontent.com/62123161/110749938-189aee00-8285-11eb-9227-93f4fc395e61.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/110749938-189aee00-8285-11eb-9227-93f4fc395e61.png\" alt=\"image\"></a></p>\n<ul>\n<li><p>각종 브라우저에서 기본 WebRTC Framework 을 지원하고 , 브라우저를 통해서는 별다른 설정없이 1:1 실시간 화상통화 기능은 즉시 사용가능함.<br>&nbsp;&nbsp; - 브라우저 자체엔진에서 WebRTC Framework 탑재.<br>&nbsp;&nbsp; - HTML 기반 API 제공하고 있음.<br>&nbsp;&nbsp; - OS or Browser Version 별 지원내역 ( ref&gt; wikipedia )<br>&nbsp;&nbsp;&nbsp;&nbsp; - Desktop Browser (MS-Edge 12+, Google Chrome 28+, Mozilla Firefox 22+, Safari 11+, Opera 18+, Vivaldi 1.9+)<br>&nbsp;&nbsp;&nbsp;&nbsp; - Android (Google Chrome 28+, Mozilla Firefox 24+, Opera Mobile 12+)<br>&nbsp;&nbsp;&nbsp;&nbsp; - Chrome OS / Firefox OS / BlackBerry 10<br>&nbsp;&nbsp;&nbsp;&nbsp; - iOS 11(MobileSafari/WebKit)<br>&nbsp;&nbsp;&nbsp;&nbsp; - Tizen 3.0</p>\n</li>\n<li><p>1:1 (Peer to Peer) 동작 지원이 기본 사양.</p>\n</li>\n<li><p>1:N 및 방화벽을 경유하는 영상/음성 전송을 제공하기 위해서는 별도의 서버(TURN/STUN) 를 구축 필요.<br>&nbsp;&nbsp; - 대부분의 방화벽모델은 Port Forwarding Rule 설정을 통해 해결됨.<br>&nbsp;&nbsp; - 방화벽이 Symmetric NAT 인 경우 Outbound IP Address 가 달라지므로, 외부에서 접속할 방법이 없어져 동작 불가능.<br>&nbsp;&nbsp; Solution) TURN Relay  : Public Domain 에 Relay Server 를 두고 이를 통해 영상/음성 Data 를 Routing 하는 것으로 해결.</p>\n</li>\n</ul>\n<h3 id=\"Protocol-Stack\"><a href=\"#Protocol-Stack\" class=\"headerlink\" title=\"Protocol Stack\"></a>Protocol Stack</h3><ul>\n<li>WebRTC 기능 개발시 RTCPeerConnection , RTCDataChannel API 는 아래와 같이 구성됨.</li>\n<li>Secure 채널을 제공하기위해 ICE/STUN/TURN 위에 DTLS 를 사용.(Mandatory feature)</li>\n<li>UDP 특성상 congestion control , flow control reliability 를 제공하지 않음에 따라</li>\n<li>SRTP / SCTP 를 통한 Connection setup / Data Delivery 를 사용함.</li>\n</ul>\n<p><a href=\"https://user-images.githubusercontent.com/62123161/110750295-9ced7100-8285-11eb-82a8-affa6f8e55d4.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/110750295-9ced7100-8285-11eb-82a8-affa6f8e55d4.png\" alt=\"image\"></a></p>\n<h3 id=\"APIs\"><a href=\"#APIs\" class=\"headerlink\" title=\"APIs\"></a>APIs</h3><p>WebRTC 의 주요 구성요소는 각 Platform ( Browser 기반, Android 기반, iOS 기반 ) 별로 표준화된(유사한) API 를 제공하고,<br>이를 통해 각 Client Application 을 제작, 배포 가능.</p>\n<h4 id=\"Interfaces\"><a href=\"#Interfaces\" class=\"headerlink\" title=\"Interfaces\"></a>Interfaces</h4><ul>\n<li>getUserMedia<br>&nbsp;&nbsp; - Webcam/audio등의 사용권한 요청.</li>\n<li>RTCPeerConnection<br>&nbsp;&nbsp; - ICE agent 역할을 수행하는 Object, Signaling channel을 통해 획득한 sdp/ice candidate등을 등록하여, ICE gathering수행.<br>&nbsp;&nbsp; - RTCIceCanddiate/ RTCConfiguration 객체등을 사용함.<br>&nbsp;&nbsp; - Peer와 컨넥션 생성 후 미디어 전송을 위한 RTCRtpSender/RTCRtpReceiver/RTCRtpTransceiver등을 획득할 수 있음.<br>&nbsp;&nbsp; - addTrack을 이용해서 전송하고자 하는 미디어 트랙을 추가 할 수 있음<br>&nbsp;&nbsp; - createDataChennel을 통해서 데이터 전송을 위한 커넥션 생성가능. (채팅/파일전송등)</li>\n<li>RTCDataChannel</li>\n<li>RTCDataChannelEvent</li>\n<li>RTCSessionDescription<br>&nbsp;&nbsp; - SDP정보</li>\n<li>RTCStatsReport</li>\n<li>RTCIceCandidate<br>&nbsp;&nbsp; - ICE candidate정보</li>\n<li>RTCIceTransport<br>&nbsp;&nbsp; - ICE agent의 상태확인 가능/ gathering state/ local, remote candidates, 이 Agent의 role./ selected candidate pair등</li>\n<li>RTCPeerConnectionIceEvent</li>\n<li>RTCRtpSender<br>&nbsp;&nbsp; - 주어진 MediaStreamTrack의 전송을 제어 할 수 있음.<br>&nbsp;&nbsp; - MediaStreamTrack변경<br>&nbsp;&nbsp; - 전송상태 확인가능</li>\n<li>RTCRtpReceiver<br>&nbsp;&nbsp; - 수신중인 MediaStream의 미디어속성/TLS속성/상태 확인가능.</li>\n<li>RTCTrackEvent</li>\n<li>RTCSctpTransport</li>\n</ul>\n<h3 id=\"Service-Component\"><a href=\"#Service-Component\" class=\"headerlink\" title=\"Service Component\"></a>Service Component</h3><p>WebRTC Service 는 다음 세가지로 구성되고 서비스 목적에 따라 각 구성 요소별 별도 Configuration 이 필요</p>\n<ul>\n<li><p>WebRTC Gateway<br>WebRTC 의 Signaling 방식은 Web 방식임에 따라 각 Peer 간의 initial Connection 을 위해 WebServer 가 필요함.<br>node.js 또는 XHR 처리가 가능한 Server 로 구성필요.</p>\n</li>\n<li><p>WebRTC Client</p>\n</li>\n<li><p>TURN/STUN Server</p>\n</li>\n</ul>\n<h3 id=\"Testing-Flow\"><a href=\"#Testing-Flow\" class=\"headerlink\" title=\"Testing Flow?\"></a>Testing Flow?</h3><p><a href=\"https://user-images.githubusercontent.com/62123161/110750602-138a6e80-8286-11eb-8e75-6078530b7e56.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/110750602-138a6e80-8286-11eb-8e75-6078530b7e56.png\" alt=\"image\"></a></p>\n","categories":[{"name":"aws","slug":"aws","count":19,"path":"api/categories/aws.json"}],"tags":[{"name":"AWS","slug":"AWS","count":20,"path":"api/tags/AWS.json"},{"name":"Kinesis","slug":"Kinesis","count":4,"path":"api/tags/Kinesis.json"},{"name":"WebRTC","slug":"WebRTC","count":1,"path":"api/tags/WebRTC.json"}]}