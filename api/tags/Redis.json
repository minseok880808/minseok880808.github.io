{"name":"Redis","slug":"Redis","count":1,"posts":[{"title":"Redis","slug":"Redis","date":"2021-04-20T01:26:57.000Z","updated":"2021-04-22T08:16:31.128Z","comments":true,"pin":null,"path":"api/articles/Redis.json","excerpt":"","keywords":null,"cover":"https://user-images.githubusercontent.com/62123161/115353865-f8e7d580-a1f3-11eb-8e26-b0b4ee5ec8e5.png","content":"<h2 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h2><ul>\n<li>인메모리 Key-Value형 데이터베이스.</li>\n<li>오픈소스</li>\n<li>data structure 지원<blockquote>\n<p>Strings, set, hash, list<br>sorted-set(랭킹시스템 할때 좋음) But, 데이터 100만건 넘어가면 느려짐(초당 백만건 순회)<br>Hyperlog, bitmap, geospatial index<br>Stream</p>\n</blockquote>\n</li>\n<li>싱글스레드 : v4.0부터는 4개의 Thread를 가지지만, 메인스레드 한개만 돌고 나머지는 유휴상태(sub thread)에 있다가 메인스레드에 문제가 생기면 메인스레드가 됨.</li>\n<li>속도가 빠름.</li>\n</ul>\n<h2 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h2><p><a href=\"https://gofnrk.tistory.com/35\" target=\"_blank\" rel=\"noopener\">https://gofnrk.tistory.com/35</a></p>\n<ul>\n<li>위 주소를 통해 설치를 하면 되며, 별다른 설정없이도 기본기능은 사용할 수 있음.</li>\n</ul>\n<h2 id=\"CLI\"><a href=\"#CLI\" class=\"headerlink\" title=\"CLI\"></a>CLI</h2><ul>\n<li>Windows 기준</li>\n<li>설치폴더(C:\\Program Files\\Redis) 내 redis-cli.exe 를 통하여 Command를 날릴 수 있음.<br><a href=\"https://user-images.githubusercontent.com/62123161/115353865-f8e7d580-a1f3-11eb-8e26-b0b4ee5ec8e5.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/115353865-f8e7d580-a1f3-11eb-8e26-b0b4ee5ec8e5.png\" alt=\"image\"></a></li>\n</ul>\n<h2 id=\"사용시-주의사항\"><a href=\"#사용시-주의사항\" class=\"headerlink\" title=\"사용시 주의사항\"></a>사용시 주의사항</h2><ul>\n<li>메모리 관리<ol>\n<li>physical memory 이상을 사용하면 swap 메모리를 사용(swap 사용하면 메모리 page 접근시마다 읽고 쓰기 때문에 엄청 느려짐)</li>\n<li>적은 메모리 사용하는 instance 여러개가 안전</li>\n<li>큰 메모리일시 elastic cache 쓰면 상관없음(걔가 알아서 관리해줌)</li>\n<li>메모리 파편화<ul>\n<li>실제로 메모리 파편화가 많이 발생함</li>\n<li>jemlloc 버전에 따라서 다르게 파편화가 발생<ul>\n<li>jemlloc 4.x 대 부터 메모리 파편화 줄이기 위한 jemalloc에 힌트를 주는 기능이 들어감</li>\n<li>jemlloc 3.x 버전은 used memory 2GB라고 나오지만 실제론 11GB RSS를 사용하는 경우가 자주 발생함</li>\n</ul>\n</li>\n<li>다양한 사이즈를 가지는 데이터보단 유사크기의 데이터를 가지는 경우가 유리함</li>\n</ul>\n</li>\n<li>메모리 부족시?<ul>\n<li>장비 마이그레이션<ul>\n<li>메모리 빡빡하면 마이그레이션중 문제생길수도 있다 넉넉하게 하자</li>\n</ul>\n</li>\n<li>있는 데이터 줄이기<ul>\n<li>특정 데이터를 줄일때 이미 swap 사용중이라면 프로세스 재시작 해야됨</li>\n</ul>\n</li>\n<li>메모리를 줄이기위한 설정<ul>\n<li>Collection<ul>\n<li>Hash -&gt; HashTable 하나 더 사용</li>\n<li>Sorted Set -&gt; Skiplist와 HashTable 이용</li>\n<li>Set -&gt; HashTable 사용</li>\n<li>위의 자료구조들은 메모리 많이 사용함</li>\n</ul>\n</li>\n<li>Ziplist 이용<ul>\n<li>인메모리 특성상 적은 개수(100만개 이하)라면 선형탐색이 정말 빠름</li>\n<li>게다가 ziplist는 기존 자료구조보다 메모리를 적게 먹음!</li>\n<li>그러니 List, hash, sorted set 등을 ziplist로 대체하자<ul>\n<li>hash-max-ziplist-entries, hash-max-ziplist-value</li>\n<li>list-max-ziplist-size, list-max-ziplist-value</li>\n<li>zset-max-ziplist-entries, zset-max-ziplist-value</li>\n</ul>\n</li>\n<li>만약 설정갯수 오버하면 원래 설정 구조로 바뀌게됨(n개 이상이면 원래 hash로 돌아감.. 이런식)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>O(n) 관련 명령어 조심하자!<ol>\n<li>오래걸리는 대표적인 O(N) 명령들[KEYS, FLUSHALL, FLUSHDB, Delete Collections, Get All Collections]<ul>\n<li>싱글스레드기에 시간을 길게잡는 명령어들은 위험하다.</li>\n<li>Key가 백만개 이상인데 Key 명령을 사용하는 경우</li>\n<li>아이템이 몇만개 든 hash, sorted set, set에서 모든 데이터를 가져오는 경우</li>\n<li>spring security oauth redis tokenStore 문제</li>\n</ul>\n</li>\n<li>대안<ul>\n<li>KEYS -&gt; Scan<ul>\n<li>scan 명령으로 하나의 긴 명령을 짧은 여러번의 명령으로 바꿈</li>\n</ul>\n</li>\n<li>Collection의 모든 아이템을 가져와야 할때<ul>\n<li>Collection 일부만 가져오거나</li>\n<li>큰 Collection을 작은 여러개의 Collection으로 나눠서 저장</li>\n<li>Userranks -&gt; Userrank1, Userrank2, Userrank3</li>\n<li>개당 몇천개 안쪽으로 저장하는게 좋음</li>\n</ul>\n</li>\n<li>Spring security oauth RedisTokenStore 이슈<ul>\n<li>스프링 시큐리티 레디스 토큰조회를 O(N) 으로 하고있었음</li>\n<li>100만개 넘어가면 검색/삭제 한번 하는데에 1초씩 걸렸음</li>\n<li>O(N) -&gt; O(1) 로 고쳐짐, 따라서 지금은 괜찮음</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"별첨-Redis-Setting\"><a href=\"#별첨-Redis-Setting\" class=\"headerlink\" title=\"별첨 : Redis Setting\"></a>별첨 : Redis Setting</h2><ol>\n<li><p>General</p>\n<ul>\n<li>databases</li>\n<li>logfile</li>\n<li>pidfile</li>\n<li>daemonize</li>\n<li>bind</li>\n<li>port</li>\n<li>tcp-backlog</li>\n</ul>\n</li>\n<li><p>AOF(Append Only File)</p>\n<ul>\n<li>aof-load-truncated    </li>\n<li>aof-rewrite-incremental-fsync</li>\n<li>appendfsync</li>\n<li>appendonly</li>\n<li>auto-aof-rewrite-min-size</li>\n<li>auto-aof-rewrite-percentage</li>\n<li>no-appendfsync-on-rewrite</li>\n</ul>\n</li>\n<li><p>RDB</p>\n<ul>\n<li>dbfilename</li>\n<li>rdbchecksum</li>\n<li>rdbcompression</li>\n<li>save</li>\n<li>stop-writes-on-bgsave-error</li>\n</ul>\n</li>\n<li><p>Replication</p>\n<ul>\n<li>slaveof    </li>\n<li>slave-read-only    </li>\n<li>slave-priority</li>\n<li>slave-serve-stale-data</li>\n<li>repl-backlog-size</li>\n<li>repl-backlog-ttl</li>\n<li>repl-disable-tcp-nodelay</li>\n<li>repl-diskless-sync</li>\n<li>repl-diskless-sync-delay</li>\n<li>repl-ping-slave-period</li>\n<li>repl-timeout</li>\n<li>min-slaves-max-lag</li>\n<li>min-slaves-to-write</li>\n</ul>\n</li>\n<li><p>Memory</p>\n<ul>\n<li>maxmemory</li>\n<li>maxmemory-policy</li>\n<li>maxmemory-samples</li>\n</ul>\n</li>\n<li><p>Cluster</p>\n<ul>\n<li>cluster-migration-barrier</li>\n<li>cluster-node-timeout</li>\n<li>cluster-require-full-coverage</li>\n<li>cluster-slave-validity-factor</li>\n</ul>\n</li>\n<li><p>Etc</p>\n<ul>\n<li>dir</li>\n<li>loglevel</li>\n<li>tcp-keepalive</li>\n<li>timeout</li>\n<li>client-output-buffer-limit</li>\n<li>maxclients</li>\n<li>list-max-ziplist-entries</li>\n<li>list-max-ziplist-value</li>\n<li>hash-max-ziplist-entries</li>\n<li>hash-max-ziplist-value</li>\n<li>set-max-intset-entries</li>\n<li>zset-max-ziplist-entries</li>\n<li>zset-max-ziplist-value</li>\n<li>activerehashing</li>\n<li>hll-sparse-max-bytes</li>\n<li>hz</li>\n<li>latency-monitor-threshold</li>\n<li>requirepass</li>\n<li>masterauth</li>\n<li>notify-keyspace-events</li>\n<li>slowlog-log-slower-than</li>\n<li>slowlog-max-len</li>\n<li>unixsocket</li>\n<li>unixsocketperm</li>\n<li>lua-time-limit</li>\n<li>watchdog-period</li>\n</ul>\n</li>\n</ol>\n<p>관련출처 : <a href=\"https://sehajyang.github.io/2019/12/11/how-to-operate-redis/\" target=\"_blank\" rel=\"noopener\">https://sehajyang.github.io/2019/12/11/how-to-operate-redis/</a></p>\n","text":"개요인메모리 Key-Value형 데이터베이스.오픈소스data structure 지원Strings, set, hash, list<br>sorted-set(랭킹시스템 할때 좋음) But, 데이터 100만건 넘어가면 느려짐(초당 백만건 순회)<br>Hype","link":"","raw":null,"photos":[],"categories":[{"name":"aws","slug":"aws","count":19,"path":"api/categories/aws.json"}],"tags":[{"name":"Redis","slug":"Redis","count":1,"path":"api/tags/Redis.json"},{"name":"key","slug":"key","count":1,"path":"api/tags/key.json"},{"name":"value","slug":"value","count":1,"path":"api/tags/value.json"},{"name":"inmemory","slug":"inmemory","count":1,"path":"api/tags/inmemory.json"},{"name":"db","slug":"db","count":1,"path":"api/tags/db.json"}]}]}