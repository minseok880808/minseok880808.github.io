{"name":"base","slug":"base","count":1,"posts":[{"title":"HTTP Structure","slug":"HTTP-Structure","date":"2021-04-27T00:05:54.000Z","updated":"2021-04-27T00:18:52.856Z","comments":true,"pin":null,"path":"api/articles/HTTP-Structure.json","excerpt":"","keywords":null,"cover":"https://user-images.githubusercontent.com/62123161/116166199-72be1880-a738-11eb-9d98-9c81fbc1cbba.png","content":"<h2 id=\"통신-Method\"><a href=\"#통신-Method\" class=\"headerlink\" title=\"통신 Method\"></a>통신 Method</h2><ul>\n<li><p>GET: 지정된 리소스(URI)를 요청</p>\n</li>\n<li><p>POST: 서버가 클라이언트의 폼 입력 필드 데이터의 수락을 요청. 클라이언트는 서버로 HTTP Body에 Data를 전송</p>\n</li>\n<li><p>HEAD: 문서의 헤더 정보만 요청하며, 응답데이터(body)를 받지 않는다.</p>\n</li>\n<li><p>PUT: 클라이언트가 전송한 데이터를 지정한 uri로 대체한다. ftp의 PUT과 동일하며, 클라이언트는 서버로 HTTP Body에 Data를 전송한다.</p>\n</li>\n<li><p>DELETE: 클라이언트가 지정한 URI를 서버에서 삭제한다.</p>\n</li>\n<li><p>TRACE: 클라이언트가 요청한 자원에 도달하기 까지의 경로를 기록하는 루프백(loop back) 검사용. 클라이언트가 요청 자원에 도달하기 까지 거쳐가는 프록시나 게이트웨이의 중간 경로부터 최종 수진 서버까지의 경로를 알아낼때 사용</p>\n</li>\n</ul>\n<p>ps. Node.js에서 app.all() 사용하는 이유 : app.use는 주로 해당 app이나 router 로 요청할 경우, 반드시 선행되어야하는 함수나 미들웨어를 추가하기 위해 사용한다. 헤더를 따로 설정하여 주기 좋고 모든 Method를 포괄할 수 있는 장점은 있으나, express의 CORS 미들웨어를 적용하는 방식이 편하므로 method를 직접 정해주는 게 나을 것으로 보인다.</p>\n<h2 id=\"Header-분석-및-예시\"><a href=\"#Header-분석-및-예시\" class=\"headerlink\" title=\"Header 분석 및 예시\"></a>Header 분석 및 예시</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET http://goddaehee.tistory.com/168 HTTP/1.1</span><br><span class=\"line\"> </span><br><span class=\"line\">//요청을 한 서버의 Host</span><br><span class=\"line\">Host: goddaehee.tistory.com</span><br><span class=\"line\"> </span><br><span class=\"line\">//클라이언트와 서버의 연결 방식 설정 HTTP/1.1은 kepp-alive 로 연결 유지하는게 디폴트.</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\"> </span><br><span class=\"line\">//클라이언트 소프트웨어(브라우저, os 등)의 이름과 버전 등</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36</span><br><span class=\"line\"> </span><br><span class=\"line\">//클라이언트가 허용할 수 있는 파일 형식(MIME TYPE)</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class=\"line\"> </span><br><span class=\"line\">//특정 페이지에서 링크를 클릭하여 요청을 하였을 경우에 나타나는 필드로써 링크를 제공한 페이지를 나타냄</span><br><span class=\"line\">Referer: http://goddaehee.tistory.com/</span><br><span class=\"line\"> </span><br><span class=\"line\">//클라이언트가 인식할 수 있는 인코딩(압축_방법으로 위의 내용에서는 서버에서 gzip, deflate로 압축한 리소스를 클라이언트가 해석할 수 있다는 말이됨</span><br><span class=\"line\">//만일 서버에서 압축을 했다면 응답헤더에 Content-Encoding 헤더에 해당 압축 방법이 명시됨.</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\"> </span><br><span class=\"line\">//클라이언트가 인식할 수 있는 언어로 우선 순위 지정이 가능</span><br><span class=\"line\">Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span><br><span class=\"line\"> </span><br><span class=\"line\">//웹서버가 클라이언트에 쿠키를 저장해 놓았다면 해당 쿠키의 정보를 이름-값 쌍으로 웹서버에 전송</span><br><span class=\"line\">Cookie: menuEnabled=1;</span><br><span class=\"line\"> </span><br><span class=\"line\">//페이지가 수정되었으면 최신 버전 페이지 요청을 위한 필드, 만일 요청한 파일이 이 필드에 지정된 시간 이후로 변경되지 않았다면, 서버로부터 데이터를 전송받지 않음</span><br><span class=\"line\">If-Modified-Since: Fri, 21 Jul 2006 05:31:13 GMT</span><br><span class=\"line\"> </span><br><span class=\"line\">//서버에 ETag가 달라졌는지 검사를 요청. ETag가 다를 경우에만 컨텐츠를 새로 받음. 만약, ETag가 같다면 서버는 304 Not Modified를 응답해서 캐시를 그대로 사용</span><br><span class=\"line\">If-None-Match: <span class=\"string\">\"734237e186acc61:a1b\"</span></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"이외-HTTP-Header-항목들\"><a href=\"#이외-HTTP-Header-항목들\" class=\"headerlink\" title=\"이외 HTTP Header  항목들\"></a>이외 HTTP Header  항목들</h2><ul>\n<li>Authorization<ul>\n<li>인증 토큰(JWT/Bearer 토큰)을 서버로 보낼 때 사용하는 헤더</li>\n<li>“토큰의 종류(Basic, Bearer 등) + 실제 토큰 문자”를 전송</li>\n</ul>\n</li>\n<li>Origin<ul>\n<li>서버로 POST 요청을 보낼 때, 요청이 어느 주소에서 시작되었는지 나타낸다.</li>\n<li>여기서 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러가 발생한다.</li>\n<li>응답 헤더의 Access-Control-Allow-Origin와 관련</li>\n</ul>\n</li>\n<li>Cache-Control<ul>\n<li>Ex) Cache-Control: no-store<ul>\n<li>아무것도 캐싱하지 않는다.</li>\n</ul>\n</li>\n<li>Ex) Cache-Control: no-cache<ul>\n<li>모든 캐시를 쓰기 전에 서버에 해당 캐시를 사용해도 되는지 확인한다.</li>\n</ul>\n</li>\n<li>Ex) Cache-Control: must-revalidate<ul>\n<li>만료된 캐시만 서버에 확인을 받도록 한다.</li>\n</ul>\n</li>\n<li>Ex) Cache-Control: public<ul>\n<li>공유 캐시(또는 중개 서버)에 저장해도 된다는 것을 의미한다.</li>\n</ul>\n</li>\n<li>Ex) Cache-Control: private<ul>\n<li>브라우저같은 특정 사용자 환경에만 저장한다.</li>\n</ul>\n</li>\n<li>Ex) Cache-Control: max-age<ul>\n<li>캐시 유효시간을 명시한다.</li>\n</ul>\n</li>\n<li>주로 응답 헤더로 사용하지만, “클라이언트 - 중개 서버 - 서버”의 구조에서 중개 서버의 캐시를 가져오지 않도록 하려면 클라이언트에서 요청 헤더에 이 헤더를 추가한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"캐시-쿠키-세션-JWT의-차이\"><a href=\"#캐시-쿠키-세션-JWT의-차이\" class=\"headerlink\" title=\"캐시, 쿠키, 세션, JWT의 차이\"></a>캐시, 쿠키, 세션, JWT의 차이</h2><h3 id=\"캐시-Cache\"><a href=\"#캐시-Cache\" class=\"headerlink\" title=\"캐시 (Cache)\"></a>캐시 (Cache)</h3><ul>\n<li>개념<ul>\n<li>CPU와 주기억장치 사이에 물리적으로 존재하는 버퍼 형태의 고속의 기억장치를 말한다. (통상, 컴퓨터 메모리 버퍼를 지칭)</li>\n</ul>\n</li>\n<li>사용 목적<ul>\n<li>CPU와 주기억장치 사이의 속도의 차이를 완화 (메모리 읽기 속도 개선용)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"쿠키-Cookie\"><a href=\"#쿠키-Cookie\" class=\"headerlink\" title=\"쿠키 (Cookie)\"></a>쿠키 (Cookie)</h3><ul>\n<li>개념<ul>\n<li>인터넷 웹 상에서 상태정보를 클라이언트측(인터넷 웹브라우저)에 저장하여, 서버측에서 필요할 때마다 지속성있게 활용하고자 할 때 사용한다. (클라이언트 로컬에 저장되는 키와 값이 들어있는 파일)</li>\n</ul>\n</li>\n<li>사용 목적<ul>\n<li>HTTP의 비연결(Connectionless)과 무상태(Stateless)을 보완</li>\n<li>웹 브라우저에 서버측에 있는 상태값들을 저장할 수 있게하도록 하여 사용자에 대한 지속적인 상태감시 및 상태참조를 한다.</li>\n</ul>\n</li>\n<li>쿠키 저장<ul>\n<li>웹 서버는, HTTP 헤더 내 Set-Cookie:란에 셋팅할 쿠키 관련 정보를 실려 보낸다.</li>\n<li>웹 브라우저는, 쿠키를 도메인 서버 이름으로 정렬된 쿠키 디렉토리에 저장한다.</li>\n<li>쿠키 구성요소</li>\n<li>쿠키의 이름(name)</li>\n<li>쿠키의 값(value)</li>\n<li>쿠키의 만료시간(Expires)</li>\n<li>쿠키를 전송할 도메인 이름(Domain)</li>\n<li>쿠키를 전송할 경로(Path)</li>\n<li>보안 연결 여부(Secure)</li>\n<li>HttpOnly 여부(HttpOnly)</li>\n</ul>\n</li>\n<li>동작방식<br><a href=\"https://user-images.githubusercontent.com/62123161/116166199-72be1880-a738-11eb-9d98-9c81fbc1cbba.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/116166199-72be1880-a738-11eb-9d98-9c81fbc1cbba.png\" alt=\"image\"></a></li>\n</ul>\n<p>1) 웹브라우저가 서버에 요청<br>2) 상태를 유지하고 싶은 값을 쿠키(cookie)로 생성<br>3) 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set−Cookie: id=doy</span><br></pre></td></tr></table></figure></div>\n<p>4) 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cookie: id=doy</span><br></pre></td></tr></table></figure></div>\n<p>5) 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인한 후 응답</p>\n<h3 id=\"세션-Session\"><a href=\"#세션-Session\" class=\"headerlink\" title=\"세션(Session)\"></a>세션(Session)</h3><ul>\n<li>개념<ul>\n<li>일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.</li>\n<li>즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다.</li>\n</ul>\n</li>\n<li>동작 방식<br><a href=\"https://user-images.githubusercontent.com/62123161/116166282-a39e4d80-a738-11eb-98e5-c2ade3366934.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/116166282-a39e4d80-a738-11eb-98e5-c2ade3366934.png\" alt=\"image\"></a></li>\n</ul>\n<p>1) 웹브라우저가 서버에 요청<br>2) 서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함<br>3) 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 Session ID를 포함해서 전송<br>쿠키에 Session ID를 JSESSIONID 라는 이름으로 저장</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set−Cookie: JSESSIONID=xslei13f</span><br></pre></td></tr></table></figure></div>\n<p>4) 웹브라우저는 이후 웹브라우저를 닫기까지 다음 요청 때 부여된 Session ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cookie: JSESSIONID=xslei13f</span><br></pre></td></tr></table></figure></div>\n<p>5) 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답</p>\n<h3 id=\"쿠키와-세션의-차이점\"><a href=\"#쿠키와-세션의-차이점\" class=\"headerlink\" title=\"쿠키와 세션의 차이점\"></a>쿠키와 세션의 차이점</h3><ul>\n<li>저장 위치<ul>\n<li>쿠키 : 클라이언트</li>\n<li>세션 : 서버</li>\n</ul>\n</li>\n<li>보안<ul>\n<li>쿠키 : 클라이언트에 저장되므로 보안에 취약하다.</li>\n<li>세션 : 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.</li>\n</ul>\n</li>\n<li>라이프사이클<ul>\n<li>쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.</li>\n<li>세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.</li>\n</ul>\n</li>\n<li>속도<ul>\n<li>쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.</li>\n<li>세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JWT-AccessToken\"><a href=\"#JWT-AccessToken\" class=\"headerlink\" title=\"JWT(AccessToken)\"></a>JWT(AccessToken)</h2><ul>\n<li>구성 요소<ul>\n<li>Header : 암호화할 방식(alg), 타입(type) 등</li>\n<li>Payload : 서버에서 보낼 데이터가 들어갑니다. 일반적으로 유저의 고유 ID값, 유효기간이 들어갑니다.</li>\n<li>Verify Signature : Base64 방식으로 인코딩한 Header,payload 그리고 SECRET KEY를 더한 후 서명됩니다.</li>\n</ul>\n</li>\n<li>최종Return값<ul>\n<li>Encoded Header + “.” + Encoded Payload + “.” + Verify Signature</li>\n</ul>\n</li>\n<li>Flow Chart<br><a href=\"https://user-images.githubusercontent.com/62123161/116166427-f37d1480-a738-11eb-8f77-b9d69d594f3c.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/116166427-f37d1480-a738-11eb-8f77-b9d69d594f3c.png\" alt=\"image\"></a></li>\n</ul>\n<ol>\n<li>사용자가 로그인을 한다.</li>\n<li>서버에서는 계정정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 넣습니다.</li>\n<li>JWT 토큰의 유효기간을 설정합니다.</li>\n<li>암호화할 SECRET KEY를 이용해 ACCESS TOKEN을 발급합니다.</li>\n<li>사용자는 Access Token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보냅니다.</li>\n<li>서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작 여부, 유효기간을 확인합니다.</li>\n<li>검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져옵니다.  </li>\n</ol>\n<h3 id=\"세션-쿠키와-JWT의-차이점\"><a href=\"#세션-쿠키와-JWT의-차이점\" class=\"headerlink\" title=\"세션/쿠키와 JWT의 차이점\"></a>세션/쿠키와 JWT의 차이점</h3><ul>\n<li>세션/쿠키 : 저장소에 유저의 정보를 넣음</li>\n<li>JWT : 토큰안에 유저정보를 넣음. 대신, 인증을 위해 암호화를 함.</li>\n</ul>\n<h2 id=\"별첨\"><a href=\"#별첨\" class=\"headerlink\" title=\"별첨\"></a>별첨</h2><ol>\n<li>NodeJS에서 body-parser 왜쓰는지?</li>\n</ol>\n<ul>\n<li><p>Express 버전 확인을 위해 (npm list -g) 명령어를 활용하거나, package lock.json 을 활용하면 된다.</p>\n</li>\n<li><p>Express 4.16.0 이하버전에서는 body-parser가 필요로 하지만, 이상의 버전에서는 app.use(express.json()) 으로 파싱이 가능하다.</p>\n</li>\n<li><p>또한, querystring 모듈을 활용할 수도 있다.</p>\n</li>\n</ul>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var qs = require(<span class=\"string\">'querystring'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">function</span> (request, response) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (request.method == <span class=\"string\">'POST'</span>) &#123;</span><br><span class=\"line\">        var body = <span class=\"string\">''</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        request.on(<span class=\"string\">'data'</span>, <span class=\"keyword\">function</span> (data) &#123;</span><br><span class=\"line\">            body += data;</span><br><span class=\"line\"> </span><br><span class=\"line\">            // Too much POST data, <span class=\"built_in\">kill</span> the connection!</span><br><span class=\"line\">            // 1e6 === 1 * Math.pow(10, 6) === 1 * 1000000 ~~~ 1MB</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (body.length &gt; 1e6)</span><br><span class=\"line\">                request.connection.destroy();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        request.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">            var post = qs.parse(body);</span><br><span class=\"line\">            // use post[<span class=\"string\">'blah'</span>], etc.</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>Header 정보 획득방법</li>\n</ol>\n<ul>\n<li><dl><dt>일단, npm모듈을 활용하는 방법이 있다.</dt><dd>npm install parse-headers</dd></dl></li>\n<li><p>input</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var parse = require(<span class=\"string\">'./parse-headers'</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  , headers = [</span><br><span class=\"line\">        <span class=\"string\">'Date: Sun, 17 Aug 2014 16:24:52 GMT'</span></span><br><span class=\"line\">      , <span class=\"string\">'Content-Type: text/html; charset=utf-8'</span></span><br><span class=\"line\">      , <span class=\"string\">'Transfer-Encoding: chunked'</span></span><br><span class=\"line\">      , <span class=\"string\">'X-Custom-Header: beep'</span></span><br><span class=\"line\">      , <span class=\"string\">'X-Custom-Header: boop'</span></span><br><span class=\"line\">    ].join(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">console.log(parse(headers))</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>output</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; date: <span class=\"string\">'Sun, 17 Aug 2014 16:24:52 GMT'</span>,</span><br><span class=\"line\">  <span class=\"string\">'content-type'</span>: <span class=\"string\">'text/html; charset=utf-8'</span>,</span><br><span class=\"line\">  <span class=\"string\">'transfer-encoding'</span>: <span class=\"string\">'chunked'</span>,</span><br><span class=\"line\">  <span class=\"string\">'x-custom-header'</span>: [ <span class=\"string\">'beep'</span>, <span class=\"string\">'boop'</span> ] &#125;</span><br></pre></td></tr></table></figure></div>\n</li>\n</ul>\n<ol start=\"3\">\n<li>HTTP 통신상 전문이 어떻게 타고 들어가는지?<br><a href=\"https://user-images.githubusercontent.com/62123161/116166596-5078ca80-a739-11eb-8f04-bec473a07090.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/116166596-5078ca80-a739-11eb-8f04-bec473a07090.png\" alt=\"image\"></a></li>\n</ol>\n<p>(IP/Port) or(DNS) 를 통해서 API서버로 요청이 들어온걸로 가정하면,</p>\n<p>1) 최초 app.js내에서 Express내 application.js handler 로 진입.(Default Configuration은 기본적으로 수행되니 생략)<br>2) 핸들러에서 라우터를 확인하고 HTTP Method를 확인한 뒤, Layer Stack을 수정해서 적용하고 Layer로 데이터를 보냄.<br>3) Layer는 여러 MiddleWare를 사용하며, (proto.process_params)에서 Req, Res 데이터들을 각각 분류하여 저장 및 생성.<br>4) Layer내에서 모두 셋팅이 끝나면 Router로 해당 데이터를 보냄.<br>5) 사용자가 요청한 데이터를 req에 받을 수 있고, Method를 통해 res데이터를 주는 것을 미리 Layer에서 셋팅된 res로 셋팅하여 내보낼 수 있음.</p>\n","text":"통신 MethodGET: 지정된 리소스(URI)를 요청POST: 서버가 클라이언트의 폼 입력 필드 데이터의 수락을 요청. 클라이언트는 서버로 HTTP Body에 Data를 전송HEAD: 문서의 헤더 정보만 요청하며, 응답데이터(body)를 받지 않는다","link":"","raw":null,"photos":[],"categories":[{"name":"web","slug":"web","count":1,"path":"api/categories/web.json"}],"tags":[{"name":"base","slug":"base","count":1,"path":"api/tags/base.json"},{"name":"HTTP","slug":"HTTP","count":1,"path":"api/tags/HTTP.json"}]}]}