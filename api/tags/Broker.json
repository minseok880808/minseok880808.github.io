{"name":"Broker","slug":"Broker","count":1,"posts":[{"title":"MQTT 비교","slug":"MQTT-Info","date":"2020-10-05T06:07:26.000Z","updated":"2020-11-23T01:31:25.288Z","comments":true,"pin":null,"path":"api/articles/MQTT-Info.json","excerpt":"","keywords":null,"cover":"https://user-images.githubusercontent.com/62123161/95045402-f2dd4c00-071c-11eb-9c49-2510fce691c3.png","content":"<h1 id=\"공통적인-MQTT-특성\"><a href=\"#공통적인-MQTT-특성\" class=\"headerlink\" title=\"공통적인 MQTT 특성\"></a>공통적인 MQTT 특성</h1><ul>\n<li><dl><dt>QOS (QUALITY OF SERVICE)</dt><dd>MQTT는 시스템에 참여하는 장치들의 처리 능력, 네트워크 대역폭, 메시지 오버헤드 등 주변상황에 맞게 시스템이 동작할 수 있도록 3단계 QoS(Quality of Service) 를 제공합니다.</dd></dl><ul>\n<li><p>0 : 메시지는 한번만 전달하며, 전달여부를 확인하지 않는다. Fire and Forget 타입이다.</p>\n</li>\n<li><p>1 : 메시지는 반드시 한번 이상 전달된다. 하지만 메시지의 핸드셰이킹 과정을 엄밀하게 추적하지 않기 때문에, 중복전송될 수도 있다.</p>\n</li>\n<li><p>2 : 메시지는 한번만 전달된다. 메시지의 핸드셰이킹 과정을 추적한다. 높은 품질을 보장하지만 성능의 희생이 따른다.</p>\n</li>\n<li><p>0에 가까울수록 메시지 처리에 대한 부하가 적은 대신 메시지 손실 위험이 높아집니다. 2에 가까울수록 메시지 손실 위험은 줄어들지만 메시지 처리 부하가 급격히 늘어납니다.<br>(보통 0~1 정도의 QoS를 사용하면서 메시지 손실등의 위험은 상위 어플리케이션 차원에서 관리하도록 하는듯 합니다.)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Mosquitto-특성\"><a href=\"#Mosquitto-특성\" class=\"headerlink\" title=\"Mosquitto 특성\"></a>Mosquitto 특성</h1><p><a href=\"https://user-images.githubusercontent.com/62123161/95045402-f2dd4c00-071c-11eb-9c49-2510fce691c3.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/95045402-f2dd4c00-071c-11eb-9c49-2510fce691c3.png\" alt=\"image\"></a><br>    - 단일 스레드 방식로 구현 : poll() 메소드를 이용하여 루프를 계속해서 반복하며 데이터를 받고 처리.<br>    - MQTT의 기본 기능을 충실히 지원하는 가벼운 MQTT 브로커<br>    - will(유언)<br>        a. –will-topic : 연결이 끊어지면 메세지 보낼 토픽<br>        b. –will-qos : 연결이 끊어지면 어떤 qos level로 보낼지(0~2)<br>        c. –will-payload : 연결이 끊어지면 보낼 메세지<br>    - Topic<br>        a. +, # 등 wildcard 사용가능<br>    - Session<br>        a. cleanSession 명령어를 false로 두면 완전히 연결을 끊지 않고 대기로 전환.(연결되면 자동활성화)<br>        b. HeartBeat을 전송하고 응답없으면 끊어버림. (시간, 일, 주, 월, 연도로 변경가능)<br>    - QoS(Default 0)<br>    - Client Size<br>        a. Default : 512개<br>    - MySQL과 연동<br>    - Protocol Version : 3.1 / 3.1.1<br>    - WebSocket 사용가능<br>    - 명령어 Page(<a href=\"https://mosquitto.org/man/mosquitto-8.html\" target=\"_blank\" rel=\"noopener\">https://mosquitto.org/man/mosquitto-8.html</a>)<br>    - 라이센스 없음.</p>\n<h2 id=\"Mosquitto-테스트\"><a href=\"#Mosquitto-테스트\" class=\"headerlink\" title=\"Mosquitto 테스트\"></a>Mosquitto 테스트</h2><pre><code>- https://ddnemo.tistory.com/120\n    a. https://midnightcow.tistory.com/36\n- https://deneb21.tistory.com/416</code></pre><h1 id=\"RabitMQ-특성\"><a href=\"#RabitMQ-특성\" class=\"headerlink\" title=\"RabitMQ 특성\"></a>RabitMQ 특성</h1><p>1) 신뢰성<br>    - RabbitMQ는 성능과 맞바꿀 수 있는 다양한 특성들을 제공하는데, 안정성, 영속성 배달 확인, 발행자 보증, 그리고 고가용성등이 있다.</p>\n<p>2) 유연한 라우팅<br>    - 메시지는 큐에 도착하기 전에 exchange를 통해 라우트된다.<br>    - RabbitMQ는 전형적인 라우팅 로직을 위한 몇몇 내장된 exchange 타입을 가지고 있다.<br>    - 좀 더 복잡한 라우팅을 위해서 exchange들을 서로 연결하거나, 자신만의 exchange 타입을 플러그인으로 만들수도 있다.</p>\n<p>3) 클러스터링<br>    - 지역 네트워크상에서 여러개의 RabbitMQ 서버들이 함께 클러스터링되어 단일한 논리적 브로커를 형성할 수 있다.</p>\n<p>4) 연합체(Federation)<br>    - 클러스터링이 허용하는 것보다는 좀 더 느슨하고 신뢰할 필요가 없는 연결을 필요로 하는 서버들에 대해서, RabbitMQ는 연합모델(federation model)을 제공한다.</p>\n<p>5) 고가용적 큐<br>    - 큐는 클러스터내의 여러 머신들에 걸쳐 복제될 수 있는데, 이는 하드웨어 결함시에 여러분의 메시지의 안전을 보장한다.</p>\n<p>6) 다중 프로토콜<br>    - RabbitMQ는 다양한 형태의 메시징 프로토콜을 통해서 메시징을 제공한다.</p>\n<p>7) 많은 클라이언트<br>    - 여러분이 생각할 수 있는 거의 모든 언어에 대해 RabbitMQ 클라이언트가 있다.</p>\n<p>8) 관리 UI<br>    - RabbitMQ는 메시지 브로커의 모든 것들을 모니터하고 컨트롤할 수 있는 사용하기 쉬운 관리 UI를 함께 제공한다.</p>\n<p>9) 추적(Tracing)<br>    - 만약 여러분의 메시징 시스템이 잘못 동작한다면, RabbitMQ는 여러분이 무엇이 잘못되고 있는지를 밝혀낼 수 있도록 추적 기능을 제공한다.</p>\n<p>10) 플러그인 시스템<br>    - RabbitMQ는 다른 방법으로 RabbitMQ를 확장시킬 수 있는 다양한 플러그인을 제공하는데, 여러분 스스로 플러그인을 제작할 수도 있다.</p>\n<p>11) 용어정리<br>    - Vhost(virutal host)<br>        a. Virtual Host를 통해서 하나의 RabbitMQ 인스턴스 안에 사용하고 있는 Application을 분리할 수 있습니다.<br>    - Connection<br>        a. 물리적인 TCP Connection, HTTPS -&gt; TLS(SSL) Connection을 사용<br>    - Channel<br>        a. 하나의 물리적인 Connection 내에 생성되는 가상의 Connection<br>        b. Consumer의 process나 thread는 각자 Channel을 통해 Queue에 연결 될 수 있습니다.</p>\n<p>12) Message Queue 및 Message 보존방법<br>    - RabbitMQ server가 종료(어떤 이유에서든지)후 재기동하면, 기본적으로 Queue는 모두 제거됩니다.<br>    - 이를 막기 위해서는 Queue를 생성할 때, Durable 옵션에 true를 주고 생성해야 하며, Producer가 메세지를 발송할 때, PERSISTENT_TEXT_PLAIN 옵션을 주어야 메세지가 보존됩니다.<br>    a. Queue 생성<br>    <div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqChannel.queueDeclare(rabbitmqQueueName, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, null); //QueueName 다음의 <span class=\"literal\">true</span>가 durable option</span><br></pre></td></tr></table></figure></div></p>\n<pre><code>b. Message 발송\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqChannel.basicPublish(exchangeName, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br></pre></td></tr></table></figure></div></code></pre><p>13) 라이센스 있음(<a href=\"https://ko.wikipedia.org/wiki/%EB%AA%A8%EC%A7%88%EB%9D%BC_%EA%B3%B5%EC%9A%A9_%ED%97%88%EA%B0%80%EC%84%9C\" target=\"_blank\" rel=\"noopener\">https://ko.wikipedia.org/wiki/%EB%AA%A8%EC%A7%88%EB%9D%BC_%EA%B3%B5%EC%9A%A9_%ED%97%88%EA%B0%80%EC%84%9C</a>)</p>\n<h1 id=\"RabitMQ-개념-5개\"><a href=\"#RabitMQ-개념-5개\" class=\"headerlink\" title=\"RabitMQ 개념(5개)\"></a>RabitMQ 개념(5개)</h1><p><a href=\"https://user-images.githubusercontent.com/62123161/95046057-48662880-071e-11eb-9d24-ae595f6a6042.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/95046057-48662880-071e-11eb-9d24-ae595f6a6042.png\" alt=\"image\"></a><br>    - Producer<br>        a. 메세지를 생성하고 발송하는 주체<br>        b.Producer는 Queue에 직접 접근하지 않고, 항상 Exchange를 통해 접근<br>    - Consumer<br>        a. 메세지를 수신하는 주체<br>        b. Consumer는 Queue에 직접 접근하여 메세지를 가져옴<br>    - Queue<br>        a. 메세지들이 Consumer가 소비하기 전까지 보관되는 장소<br>        b. 같은 이름과 같은 설정으로 Queue를 생성하면 에러 없이 기존 Queue에 연결되지만, 같은 이름과 다른 설정으로 Queue를 생성하려고 시도하면 에러<br>    - Exchange<br>        a. Producer들에게서 전달받은 메세지들을 어떤 Queue들에게 발송할지를 결정하는 객체<br>        b. 총 4개의 Type을 보유하며, Router 개념으로 생각하면 됨.<br>            i. Direct(default)<br>                1. Routing key가 정확히 일치하는 Queue에 메세지 전송(Unicast)<br>                2. 예시<br>                <a href=\"https://user-images.githubusercontent.com/62123161/95046159-8cf1c400-071e-11eb-8106-45aace9bedc2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/95046159-8cf1c400-071e-11eb-8106-45aace9bedc2.png\" alt=\"image\"></a><br>                (error 메세지만 저장소에 기록하고, info와 warning을 포함한 모든 정보를 디스플레이에 출력할 때를 나타내는 모식도)<br>            ii. Topic<br>                1. Routing key 패턴이 일치하는 Queue에 메세지 전송(Multicast)<br>                2. 예시<br>                <a href=\"https://user-images.githubusercontent.com/62123161/95046205-b14da080-071e-11eb-901a-b31040e5ed16.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/95046205-b14da080-071e-11eb-901a-b31040e5ed16.png\" alt=\"image\"></a><br>                (라우팅 키가 example.orange.rabbit 인 경우 메세지가 Q1, Q2에 모두 전달되고, 라우팅 키가 example.orange.turtle 인 경우 메세지가 Q1에만 전달. 라우팅 키가 lazy.grape.rabbit인 경우엔 메세지가 Q2에 한 번만 전달이 됩니다.)<br>            iii. Headers<br>                1. [key:value]로 이루어진 header 값을 기준으로 일치하는 Queue에 메세지 전송(Multicast)<br>                2. 예시<br>                <a href=\"https://user-images.githubusercontent.com/62123161/95046280-d8a46d80-071e-11eb-9236-aed3b3cb2760.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/95046280-d8a46d80-071e-11eb-9236-aed3b3cb2760.png\" alt=\"image\"></a><br>            iv. Fanout<br>                1. 해당 Exchange에 등록된 모든 Queue에 메세지 전송(Broadcast)<br>                2. 예시<br>                <a href=\"https://user-images.githubusercontent.com/62123161/95046342-f83b9600-071e-11eb-8f27-e5352204a36e.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://user-images.githubusercontent.com/62123161/95046342-f83b9600-071e-11eb-8f27-e5352204a36e.png\" alt=\"image\"></a></p>\n<pre><code>- Binding\n    a. Exchange에게 메세지를 라우팅 할 규칙을 지정하는 행위</code></pre><h1 id=\"HiveMQ-특성\"><a href=\"#HiveMQ-특성\" class=\"headerlink\" title=\"HiveMQ 특성\"></a>HiveMQ 특성</h1><pre><code>- 자세한 정보가 너무 없음.\n- 샘플소스코드에 대한 링크는 아래와 같음\n    a. https://www.hivemq.com/blog/how-to-get-started-with-mqtt/\n- 다른MQTT Message Broker과 다른점\n    a. WebSockets native support for all common WebSocket versions\n        i. 웹소켓을 지원함은 물론이고, 클라이언트 인증서를 통한 통신이 가능함.\n    b. PROXY protocol for advanced load balancer integrations\n        i. TCP 프로토콜(로드밸런서) 뒤에 위치하는 것이 효율이 가장 좋다고 함.\n    c. Open-source extension SDK an extension framework to extend HiveMQ with custom business logic or integrate practically any system into HiveMQ\n    d. HiveMQ Enterprise Extensions for Kafka to seamlessly integrate MQTT messages with one or more Kafka clusters\n        i. HiveMQ MQTT 브로커에서 메시지를 버퍼링하여 Kafka 클러스터를 일시적으로 사용할 수 없을 때마다 고가용성 및 장애 허용성을 보장\n        [![image](https://user-images.githubusercontent.com/62123161/95046590-6c763980-071f-11eb-97aa-41faad3acc20.png)](https://user-images.githubusercontent.com/62123161/95046590-6c763980-071f-11eb-97aa-41faad3acc20.png)\n    e. HiveMQ Enterprise Security Extension to secure your MQTT deployment\n        i. SQL 데이터베이스 를 통한 인증 및 권한 부여에 대한 완전한 지원\n        ii. JSON 웹 토큰을 통한 인증에 대한 완전한 지원\n        iii. 클라이언트별로 주제 권한을 개별화하는 동적 권한 자리 표시 자\n        iv. 데이터를 모니터링하고 잠재적 인 보안 위반을 추적하는 데 도움이되는 자세한 액세스 로그\n        v. 액세스 제어 에 대한 역할 기반 액세스 제어 (RBAC)를 포함 HiveMQ 제어 센터 (ESE 버전 1.2.0 이상)\n- 라이센스 있음(https://www.hivemq.com/hivemq/editions/)</code></pre><h1 id=\"Mosca-MQTT\"><a href=\"#Mosca-MQTT\" class=\"headerlink\" title=\"Mosca MQTT\"></a>Mosca MQTT</h1><pre><code>- 특성(https://github.com/moscajs/mosca)\n    a. 구조가 단순\n    b. 사용 환경에 따라 customizing 하기도 용이\n        i. REDIS나 MongoDB를 활용한 storage option도 지원\n    c. 무료 사용이 가능한 license\n    d. MQTT 3.1, 3.1.1 호환.\n    e. QoS 0 또는 QoS 1 지원.\n    f. 클라이언트 인증(토픽을 제한하는데 사용)\n        i. #authenticate\n        ii. #authorizePublish\n        iii. #authorizeSubscribe\n    g. MIT License</code></pre>","text":"공통적인 MQTT 특성QOS (QUALITY OF SERVICE)MQTT는 시스템에 참여하는 장치들의 처리 능력, 네트워크 대역폭, 메시지 오버헤드 등 주변상황에 맞게 시스템이 동작할 수 있도록 3단계 QoS(Quality of Service) 를 제","link":"","raw":null,"photos":[],"categories":[{"name":"mqtt","slug":"mqtt","count":1,"path":"api/categories/mqtt.json"}],"tags":[{"name":"MQTT","slug":"MQTT","count":1,"path":"api/tags/MQTT.json"},{"name":"Message","slug":"Message","count":1,"path":"api/tags/Message.json"},{"name":"Broker","slug":"Broker","count":1,"path":"api/tags/Broker.json"}]}]}